'use strict';

exports.__esModule = true;
exports.defaultProps = exports.propTypes = exports.columnShape = exports.gridShape = exports.configStorageShape = undefined;

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

var _reactImmutableProptypes = require('react-immutable-proptypes');

var _reactImmutableProptypes2 = _interopRequireDefault(_reactImmutableProptypes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* eslint-disable react/no-unused-prop-types, react/forbid-prop-types, max-len */
/* eslint-disable no-multi-spaces, object-curly-newline */
var bool = _propTypes2.default.bool,
    number = _propTypes2.default.number,
    string = _propTypes2.default.string,
    func = _propTypes2.default.func,
    object = _propTypes2.default.object,
    node = _propTypes2.default.node,
    array = _propTypes2.default.array,
    shape = _propTypes2.default.shape,
    any = _propTypes2.default.any,
    oneOfType = _propTypes2.default.oneOfType,
    arrayOf = _propTypes2.default.arrayOf;
var list = _reactImmutableProptypes2.default.list,
    map = _reactImmutableProptypes2.default.map,
    mapOf = _reactImmutableProptypes2.default.mapOf;
var configStorageShape = exports.configStorageShape = shape({
  load: func.isRequired,
  save: func.isRequired
});

// Grid object holds data that also actions uses
var gridShape = exports.gridShape = shape({
  id: string.isRequired,
  idKeyPath: arrayOf(string).isRequired, // keyPath to id data
  defaultShowFilteringRow: bool, // is filtering row shown as default
  defaultSortColumn: string, // columnKey of column that is sorted by default
  defaultSortOrder: string, // default sort order [asc/desc]
  disableRememberColumnWidths: bool,
  disableRememberSortData: bool,
  disableRememberIsFiltering: bool,
  disableRememberFilteData: bool,
  disableRememberSelectedItems: bool,
  language: string,
  region: string,
  dateFormat: string,
  thousandSeparator: string,
  decimalSeparator: string,
  configStorage: configStorageShape
});

var columnShape = exports.columnShape = shape({
  header: node,
  columnKey: string, // Use valueKeyPath if possible, this is calculated from there
  valueKeyPath: array, // key path for the cell data value, required if no columnKey is given
  valueType: string, // data value type [text/number/float/boolean/date]
  valueOptions: shape({ // options for the value type
    currencyKeyPath: array, // key path to currency code (only for currency data type)
    decimals: number, // number of decimals override
    thousandSeparator: string, // thousand separator override
    decimalSeparator: string // decimal separator override
  }),
  componentType: string, // edit component type [text/number/float/select/boolean/date]
  valueRender: func, // custom renderer for the value, data as parameter
  editValueRender: func, // custom renderer for the edit value, data as parameter
  createValueRender: func, // custom renderer for the create value, data as parameter
  filterValueRender: func, // custom renderer for the filter value, data as parameter
  cell: func, // override cell renderer, rowIndex as parameter
  cellEdit: func, // override cellEdit renderer, rowIndex as parameter
  cellCreate: func, // override cellCreate renderer, rowIndex as parameter
  cellFilter: func, // override cellFilter renderer, rowIndex as parameter
  renderComponentProps: object, // additional props to the render component
  editComponentProps: object, // additional props to the edit component
  createComponentProps: object, // additional props to the create component
  filterComponentProps: object, // additional props to the filter component
  width: number,
  minWidth: number,
  maxWidth: number,
  align: string, // vertical cell alignment, defaults to 'left'
  fixed: bool, // is column fixed
  allowCellsRecycling: bool, // allow cells to be recycled for better horizontal scrolling perf
  disableResizing: bool, // disable column resizing
  disableEditing: bool, // disable input component (make read-only) when editing/creating
  disableSorting: bool, // disable filtering on this column
  disableEditingOnValueMatch: shape({ // disable editing/creating input when other columns value match
    matchValueKeyPath: array,
    matchValue: any
  }),
  onValueMatchChangeValue: shape({ // Change other column value when data matches
    matchValue: any,
    newValueKeyPath: array,
    newValue: any
  }),
  flexGrow: number,
  valueEmptyChecker: func, // override function that checks if value is considered as empty
  sortValueGetter: func, // override sort value getter, defaults to getIn(valueKeyPath)
  sortComparator: func, // override sort comparator function, default sorts by valueType
  filterMatcher: func, // override filter matcher function, that defined when filter matches data
  defaultValue: any, // default value for the column when creating new item
  isRequired: bool, // is column value required
  isHidden: bool, // is column hidden by default
  onEditValueChange: func, // callback with (value, valueKeyPath, rowIndex, dataId)
  onCreateValueChange: func, // callbac with (value, valueKeyPath, rowIndex)
  onCreateBlur: func, // callback with (value, rowIndex)
  onEditBlur: func, // callback with (value, rowIndex, dataId)
  selectComponentOptions: arrayOf(shape({
    value: oneOfType([number, string, bool]).isRequired,
    label: oneOfType([number, string]).isRequired
  })),
  selectComponentTranslations: shape({ // customize select components placeholder and noResults texts.
    placeholder: string,
    noResultsText: string
  })
});

var propTypes = exports.propTypes = {
  children: node,
  // App props
  intl: object.isRequired,
  // Action props
  addNewItem: func.isRequired,
  removeNewItem: func.isRequired,
  create: func.isRequired,
  edit: func.isRequired,
  remove: func.isRequired,
  save: func.isRequired,
  cancel: func.isRequired,
  sortChange: func.isRequired,
  resizeColumn: func.isRequired,
  invalidate: func.isRequired,
  cellSelectionChange: func.isRequired,
  itemSelectionChange: func.isRequired,
  toggleFiltering: func.isRequired,
  editCellValueChange: func.isRequired,
  createCellValueChange: func.isRequired,
  filterCellValueChange: func.isRequired,
  editCellValueValidate: func.isRequired,
  createCellValueValidate: func.isRequired,
  validateEditedRows: func.isRequired,
  validateCreatedRows: func.isRequired,
  // State props
  isBusy: bool.isRequired,
  isEditing: bool.isRequired,
  isCreating: bool.isRequired,
  isFiltering: bool.isRequired,
  sortColumn: oneOfType([string, number]),
  sortOrder: string,
  visibleColumns: list.isRequired,
  columnWidths: map.isRequired,
  selectedCell: map.isRequired,
  selectedItems: list.isRequired,
  data: list.isRequired,
  editData: map.isRequired,
  createData: list.isRequired,
  filterData: map.isRequired,
  cellMessages: map.isRequired,
  createCellMessages: map.isRequired,
  language: string.isRequired,
  region: string.isRequired,
  thousandSeparator: string.isRequired,
  decimalSeparator: string.isRequired,
  allDataSize: number.isRequired,
  // Required component properties
  grid: gridShape.isRequired,
  columns: arrayOf(columnShape.isRequired).isRequired,
  // Optional component properties
  rowsCount: number,
  gridHeader: node,
  actionBar: node,
  actionBarLeft: node,
  cellSelect: bool,
  disableDropdown: bool, // Don't use dropdown menu in the action bar
  disableFilteringControls: bool, // Don't display the filtering controls (only valid if disableDropdown is true)
  dropdownMenuItems: arrayOf(shape({
    id: string,
    title: node,
    icon: node,
    onClick: func,
    disabled: oneOfType([bool, func])
  })),
  inlineEdit: bool,
  inlineAdd: bool,
  filtering: bool,
  removing: bool,
  columnSettings: bool,
  rowSelect: bool,
  rowSelectCheckboxColumn: bool,
  multiSelect: bool,
  selectComponentOptions: mapOf(arrayOf(shape({ // Options data for the react-select components
    value: oneOfType([number, string, bool]).isRequired,
    label: oneOfType([number, string]).isRequired
  }))),
  selectComponentTranslations: shape({ // Options for react-select text translations
    placeholder: string.isRequired,
    noResultsText: string.isRequired
  }),
  disableActions: bool, // Disable actions in the action bar
  disableActionsMessage: shape({
    messageId: string,
    messageValues: shape({})
  }),
  disableActionBar: bool,
  disableActionSave: bool,
  enableArrowNavigation: bool,
  onSave: func,
  onRemove: func,
  onCancel: func,
  onAddClick: func,
  onEditClick: func,
  tabIndex: number, // tabIndex value for inputs in cells
  extraColumn: shape({ // Extra fixed column that can't be re-ordered or hidden
    width: string,
    valueRender: func,
    cellEdit: func,
    cellCreate: func,
    cellFilter: func,
    isResizable: bool
  }),
  contextMenuItems: arrayOf(shape({ // Context menu items to display when row is right-clicked
    value: node,
    onClick: func,
    title: string,
    header: bool,
    disabled: oneOfType([bool, func]),
    divider: bool
  })),
  // Fixed data table built-in features
  headerHeight: number,
  filterRowHeight: number,
  rowHeight: number,
  containerStyle: object,
  scrollToColumn: number,
  scrollTop: number,
  scrollToRow: number,
  onRowClick: func,
  onRowDoubleClick: func,
  onRowMouseDown: func,
  onRowMouseEnter: func,
  onRowMouseLeave: func,
  onScrollStart: func,
  onScrollEnd: func,
  rowClassNameGetter: func,
  rowHeightGetter: func,
  onContentHeightChange: func,
  className: string,
  focusType: map.isRequired
};

/* eslint-enable max-len, prefer-template, react/no-unused-prop-types, react/forbid-prop-types */

var defaultProps = exports.defaultProps = {
  cellSelect: false,
  columnSettings: false,
  children: undefined,
  containerStyle: {},
  disableActionSave: false,
  enableArrowNavigation: false,
  headerHeight: 40,
  filterRowHeight: 40,
  rowHeight: 40,
  onSave: function onSave() {},
  onRemove: function onRemove() {},
  onCancel: function onCancel() {},
  tabIndex: 1,
  disableFilteringControls: false,
  className: ''
};
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9kYXRhZ3JpZC9kYXRhZ3JpZC5wcm9wcy5qcyJdLCJuYW1lcyI6WyJib29sIiwiUHJvcFR5cGVzIiwibnVtYmVyIiwic3RyaW5nIiwiZnVuYyIsIm9iamVjdCIsIm5vZGUiLCJhcnJheSIsInNoYXBlIiwiYW55Iiwib25lT2ZUeXBlIiwiYXJyYXlPZiIsImxpc3QiLCJJbW11dGFibGVQcm9wVHlwZXMiLCJtYXAiLCJtYXBPZiIsImNvbmZpZ1N0b3JhZ2VTaGFwZSIsImxvYWQiLCJpc1JlcXVpcmVkIiwic2F2ZSIsImdyaWRTaGFwZSIsImlkIiwiaWRLZXlQYXRoIiwiZGVmYXVsdFNob3dGaWx0ZXJpbmdSb3ciLCJkZWZhdWx0U29ydENvbHVtbiIsImRlZmF1bHRTb3J0T3JkZXIiLCJkaXNhYmxlUmVtZW1iZXJDb2x1bW5XaWR0aHMiLCJkaXNhYmxlUmVtZW1iZXJTb3J0RGF0YSIsImRpc2FibGVSZW1lbWJlcklzRmlsdGVyaW5nIiwiZGlzYWJsZVJlbWVtYmVyRmlsdGVEYXRhIiwiZGlzYWJsZVJlbWVtYmVyU2VsZWN0ZWRJdGVtcyIsImxhbmd1YWdlIiwicmVnaW9uIiwiZGF0ZUZvcm1hdCIsInRob3VzYW5kU2VwYXJhdG9yIiwiZGVjaW1hbFNlcGFyYXRvciIsImNvbmZpZ1N0b3JhZ2UiLCJjb2x1bW5TaGFwZSIsImhlYWRlciIsImNvbHVtbktleSIsInZhbHVlS2V5UGF0aCIsInZhbHVlVHlwZSIsInZhbHVlT3B0aW9ucyIsImN1cnJlbmN5S2V5UGF0aCIsImRlY2ltYWxzIiwiY29tcG9uZW50VHlwZSIsInZhbHVlUmVuZGVyIiwiZWRpdFZhbHVlUmVuZGVyIiwiY3JlYXRlVmFsdWVSZW5kZXIiLCJmaWx0ZXJWYWx1ZVJlbmRlciIsImNlbGwiLCJjZWxsRWRpdCIsImNlbGxDcmVhdGUiLCJjZWxsRmlsdGVyIiwicmVuZGVyQ29tcG9uZW50UHJvcHMiLCJlZGl0Q29tcG9uZW50UHJvcHMiLCJjcmVhdGVDb21wb25lbnRQcm9wcyIsImZpbHRlckNvbXBvbmVudFByb3BzIiwid2lkdGgiLCJtaW5XaWR0aCIsIm1heFdpZHRoIiwiYWxpZ24iLCJmaXhlZCIsImFsbG93Q2VsbHNSZWN5Y2xpbmciLCJkaXNhYmxlUmVzaXppbmciLCJkaXNhYmxlRWRpdGluZyIsImRpc2FibGVTb3J0aW5nIiwiZGlzYWJsZUVkaXRpbmdPblZhbHVlTWF0Y2giLCJtYXRjaFZhbHVlS2V5UGF0aCIsIm1hdGNoVmFsdWUiLCJvblZhbHVlTWF0Y2hDaGFuZ2VWYWx1ZSIsIm5ld1ZhbHVlS2V5UGF0aCIsIm5ld1ZhbHVlIiwiZmxleEdyb3ciLCJ2YWx1ZUVtcHR5Q2hlY2tlciIsInNvcnRWYWx1ZUdldHRlciIsInNvcnRDb21wYXJhdG9yIiwiZmlsdGVyTWF0Y2hlciIsImRlZmF1bHRWYWx1ZSIsImlzSGlkZGVuIiwib25FZGl0VmFsdWVDaGFuZ2UiLCJvbkNyZWF0ZVZhbHVlQ2hhbmdlIiwib25DcmVhdGVCbHVyIiwib25FZGl0Qmx1ciIsInNlbGVjdENvbXBvbmVudE9wdGlvbnMiLCJ2YWx1ZSIsImxhYmVsIiwic2VsZWN0Q29tcG9uZW50VHJhbnNsYXRpb25zIiwicGxhY2Vob2xkZXIiLCJub1Jlc3VsdHNUZXh0IiwicHJvcFR5cGVzIiwiY2hpbGRyZW4iLCJpbnRsIiwiYWRkTmV3SXRlbSIsInJlbW92ZU5ld0l0ZW0iLCJjcmVhdGUiLCJlZGl0IiwicmVtb3ZlIiwiY2FuY2VsIiwic29ydENoYW5nZSIsInJlc2l6ZUNvbHVtbiIsImludmFsaWRhdGUiLCJjZWxsU2VsZWN0aW9uQ2hhbmdlIiwiaXRlbVNlbGVjdGlvbkNoYW5nZSIsInRvZ2dsZUZpbHRlcmluZyIsImVkaXRDZWxsVmFsdWVDaGFuZ2UiLCJjcmVhdGVDZWxsVmFsdWVDaGFuZ2UiLCJmaWx0ZXJDZWxsVmFsdWVDaGFuZ2UiLCJlZGl0Q2VsbFZhbHVlVmFsaWRhdGUiLCJjcmVhdGVDZWxsVmFsdWVWYWxpZGF0ZSIsInZhbGlkYXRlRWRpdGVkUm93cyIsInZhbGlkYXRlQ3JlYXRlZFJvd3MiLCJpc0J1c3kiLCJpc0VkaXRpbmciLCJpc0NyZWF0aW5nIiwiaXNGaWx0ZXJpbmciLCJzb3J0Q29sdW1uIiwic29ydE9yZGVyIiwidmlzaWJsZUNvbHVtbnMiLCJjb2x1bW5XaWR0aHMiLCJzZWxlY3RlZENlbGwiLCJzZWxlY3RlZEl0ZW1zIiwiZGF0YSIsImVkaXREYXRhIiwiY3JlYXRlRGF0YSIsImZpbHRlckRhdGEiLCJjZWxsTWVzc2FnZXMiLCJjcmVhdGVDZWxsTWVzc2FnZXMiLCJhbGxEYXRhU2l6ZSIsImdyaWQiLCJjb2x1bW5zIiwicm93c0NvdW50IiwiZ3JpZEhlYWRlciIsImFjdGlvbkJhciIsImFjdGlvbkJhckxlZnQiLCJjZWxsU2VsZWN0IiwiZGlzYWJsZURyb3Bkb3duIiwiZGlzYWJsZUZpbHRlcmluZ0NvbnRyb2xzIiwiZHJvcGRvd25NZW51SXRlbXMiLCJ0aXRsZSIsImljb24iLCJvbkNsaWNrIiwiZGlzYWJsZWQiLCJpbmxpbmVFZGl0IiwiaW5saW5lQWRkIiwiZmlsdGVyaW5nIiwicmVtb3ZpbmciLCJjb2x1bW5TZXR0aW5ncyIsInJvd1NlbGVjdCIsInJvd1NlbGVjdENoZWNrYm94Q29sdW1uIiwibXVsdGlTZWxlY3QiLCJkaXNhYmxlQWN0aW9ucyIsImRpc2FibGVBY3Rpb25zTWVzc2FnZSIsIm1lc3NhZ2VJZCIsIm1lc3NhZ2VWYWx1ZXMiLCJkaXNhYmxlQWN0aW9uQmFyIiwiZGlzYWJsZUFjdGlvblNhdmUiLCJlbmFibGVBcnJvd05hdmlnYXRpb24iLCJvblNhdmUiLCJvblJlbW92ZSIsIm9uQ2FuY2VsIiwib25BZGRDbGljayIsIm9uRWRpdENsaWNrIiwidGFiSW5kZXgiLCJleHRyYUNvbHVtbiIsImlzUmVzaXphYmxlIiwiY29udGV4dE1lbnVJdGVtcyIsImRpdmlkZXIiLCJoZWFkZXJIZWlnaHQiLCJmaWx0ZXJSb3dIZWlnaHQiLCJyb3dIZWlnaHQiLCJjb250YWluZXJTdHlsZSIsInNjcm9sbFRvQ29sdW1uIiwic2Nyb2xsVG9wIiwic2Nyb2xsVG9Sb3ciLCJvblJvd0NsaWNrIiwib25Sb3dEb3VibGVDbGljayIsIm9uUm93TW91c2VEb3duIiwib25Sb3dNb3VzZUVudGVyIiwib25Sb3dNb3VzZUxlYXZlIiwib25TY3JvbGxTdGFydCIsIm9uU2Nyb2xsRW5kIiwicm93Q2xhc3NOYW1lR2V0dGVyIiwicm93SGVpZ2h0R2V0dGVyIiwib25Db250ZW50SGVpZ2h0Q2hhbmdlIiwiY2xhc3NOYW1lIiwiZm9jdXNUeXBlIiwiZGVmYXVsdFByb3BzIiwidW5kZWZpbmVkIl0sIm1hcHBpbmdzIjoiOzs7OztBQUVBOzs7O0FBQ0E7Ozs7OztBQUhBO0FBQ0E7SUFJUUEsSSxHQUFvRkMsbUIsQ0FBcEZELEk7SUFBTUUsTSxHQUE4RUQsbUIsQ0FBOUVDLE07SUFBUUMsTSxHQUFzRUYsbUIsQ0FBdEVFLE07SUFBUUMsSSxHQUE4REgsbUIsQ0FBOURHLEk7SUFBTUMsTSxHQUF3REosbUIsQ0FBeERJLE07SUFBUUMsSSxHQUFnREwsbUIsQ0FBaERLLEk7SUFBTUMsSyxHQUEwQ04sbUIsQ0FBMUNNLEs7SUFBT0MsSyxHQUFtQ1AsbUIsQ0FBbkNPLEs7SUFBT0MsRyxHQUE0QlIsbUIsQ0FBNUJRLEc7SUFBS0MsUyxHQUF1QlQsbUIsQ0FBdkJTLFM7SUFBV0MsTyxHQUFZVixtQixDQUFaVSxPO0lBQ3hFQyxJLEdBQXFCQyxpQyxDQUFyQkQsSTtJQUFNRSxHLEdBQWVELGlDLENBQWZDLEc7SUFBS0MsSyxHQUFVRixpQyxDQUFWRSxLO0FBRVosSUFBTUMsa0RBQXFCUixNQUFNO0FBQ3RDUyxRQUFNYixLQUFLYyxVQUQyQjtBQUV0Q0MsUUFBTWYsS0FBS2M7QUFGMkIsQ0FBTixDQUEzQjs7QUFLUDtBQUNPLElBQU1FLGdDQUFZWixNQUFNO0FBQzdCYSxNQUFJbEIsT0FBT2UsVUFEa0I7QUFFN0JJLGFBQVdYLFFBQVFSLE1BQVIsRUFBZ0JlLFVBRkUsRUFFVTtBQUN2Q0ssMkJBQXlCdkIsSUFISSxFQUdVO0FBQ3ZDd0IscUJBQW1CckIsTUFKVSxFQUlVO0FBQ3ZDc0Isb0JBQWtCdEIsTUFMVyxFQUtV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RUFQWTtBQVExQkMsbUJBQWlCLEVBUlM7QUFTMUJDLGFBQVcsRUFUZTtBQVUxQlosVUFBUSxrQkFBTSxDQUFFLENBVlU7QUFXMUJDLFlBQVUsb0JBQU0sQ0FBRSxDQVhRO0FBWTFCQyxZQUFVLG9CQUFNLENBQUUsQ0FaUTtBQWExQkcsWUFBVSxDQWJnQjtBQWMxQjFCLDRCQUEwQixLQWRBO0FBZTFCZ0QsYUFBVztBQWZlLENBQXJCIiwiZmlsZSI6ImRhdGFncmlkLnByb3BzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyogZXNsaW50LWRpc2FibGUgcmVhY3Qvbm8tdW51c2VkLXByb3AtdHlwZXMsIHJlYWN0L2ZvcmJpZC1wcm9wLXR5cGVzLCBtYXgtbGVuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1tdWx0aS1zcGFjZXMsIG9iamVjdC1jdXJseS1uZXdsaW5lICovXG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IEltbXV0YWJsZVByb3BUeXBlcyBmcm9tICdyZWFjdC1pbW11dGFibGUtcHJvcHR5cGVzJztcblxuY29uc3QgeyBib29sLCBudW1iZXIsIHN0cmluZywgZnVuYywgb2JqZWN0LCBub2RlLCBhcnJheSwgc2hhcGUsIGFueSwgb25lT2ZUeXBlLCBhcnJheU9mIH0gPSBQcm9wVHlwZXM7XG5jb25zdCB7IGxpc3QsIG1hcCwgbWFwT2YgfSA9IEltbXV0YWJsZVByb3BUeXBlcztcblxuZXhwb3J0IGNvbnN0IGNvbmZpZ1N0b3JhZ2VTaGFwZSA9IHNoYXBlKHtcbiAgbG9hZDogZnVuYy5pc1JlcXVpcmVkLFxuICBzYXZlOiBmdW5jLmlzUmVxdWlyZWQsXG59KTtcblxuLy8gR3JpZCBvYmplY3QgaG9sZHMgZGF0YSB0aGF0IGFsc28gYWN0aW9ucyB1c2VzXG5leHBvcnQgY29uc3QgZ3JpZFNoYXBlID0gc2hhcGUoe1xuICBpZDogc3RyaW5nLmlzUmVxdWlyZWQsXG4gIGlkS2V5UGF0aDogYXJyYXlPZihzdHJpbmcpLmlzUmVxdWlyZWQsIC8vIGtleVBhdGggdG8gaWQgZGF0YVxuICBkZWZhdWx0U2hvd0ZpbHRlcmluZ1JvdzogYm9vbCwgICAgICAgICAvLyBpcyBmaWx0ZXJpbmcgcm93IHNob3duIGFzIGRlZmF1bHRcbiAgZGVmYXVsdFNvcnRDb2x1bW46IHN0cmluZywgICAgICAgICAgICAgLy8gY29sdW1uS2V5IG9mIGNvbHVtbiB0aGF0IGlzIHNvcnRlZCBieSBkZWZhdWx0XG4gIGRlZmF1bHRTb3J0T3JkZXI6IHN0cmluZywgICAgICAgICAgICAgIC8vIGRlZmF1bHQgc29ydCBvcmRlciBbYXNjL2Rlc2NdXG4gIGRpc2FibGVSZW1lbWJlckNvbHVtbldpZHRoczogYm9vbCxcbiAgZGlzYWJsZVJlbWVtYmVyU29ydERhdGE6IGJvb2wsXG4gIGRpc2FibGVSZW1lbWJlcklzRmlsdGVyaW5nOiBib29sLFxuICBkaXNhYmxlUmVtZW1iZXJGaWx0ZURhdGE6IGJvb2wsXG4gIGRpc2FibGVSZW1lbWJlclNlbGVjdGVkSXRlbXM6IGJvb2wsXG4gIGxhbmd1YWdlOiBzdHJpbmcsXG4gIHJlZ2lvbjogc3RyaW5nLFxuICBkYXRlRm9ybWF0OiBzdHJpbmcsXG4gIHRob3VzYW5kU2VwYXJhdG9yOiBzdHJpbmcsXG4gIGRlY2ltYWxTZXBhcmF0b3I6IHN0cmluZyxcbiAgY29uZmlnU3RvcmFnZTogY29uZmlnU3RvcmFnZVNoYXBlLFxufSk7XG5cbmV4cG9ydCBjb25zdCBjb2x1bW5TaGFwZSA9IHNoYXBlKHtcbiAgaGVhZGVyOiBub2RlLFxuICBjb2x1bW5LZXk6IHN0cmluZywgICAgICAgICAgICAgIC8vIFVzZSB2YWx1ZUtleVBhdGggaWYgcG9zc2libGUsIHRoaXMgaXMgY2FsY3VsYXRlZCBmcm9tIHRoZXJlXG4gIHZhbHVlS2V5UGF0aDogYXJyYXksICAgICAgICAgICAgLy8ga2V5IHBhdGggZm9yIHRoZSBjZWxsIGRhdGEgdmFsdWUsIHJlcXVpcmVkIGlmIG5vIGNvbHVtbktleSBpcyBnaXZlblxuICB2YWx1ZVR5cGU6IHN0cmluZywgICAgICAgICAgICAgIC8vIGRhdGEgdmFsdWUgdHlwZSBbdGV4dC9udW1iZXIvZmxvYXQvYm9vbGVhbi9kYXRlXVxuICB2YWx1ZU9wdGlvbnM6IHNoYXBlKHsgICAgICAgICAgIC8vIG9wdGlvbnMgZm9yIHRoZSB2YWx1ZSB0eXBlXG4gICAgY3VycmVuY3lLZXlQYXRoOiBhcnJheSwgICAgICAgLy8ga2V5IHBhdGggdG8gY3VycmVuY3kgY29kZSAob25seSBmb3IgY3VycmVuY3kgZGF0YSB0eXBlKVxuICAgIGRlY2ltYWxzOiBudW1iZXIsICAgICAgICAgICAgIC8vIG51bWJlciBvZiBkZWNpbWFscyBvdmVycmlkZVxuICAgIHRob3VzYW5kU2VwYXJhdG9yOiBzdHJpbmcsICAgIC8vIHRob3VzYW5kIHNlcGFyYXRvciBvdmVycmlkZVxuICAgIGRlY2ltYWxTZXBhcmF0b3I6IHN0cmluZywgICAgIC8vIGRlY2ltYWwgc2VwYXJhdG9yIG92ZXJyaWRlXG4gIH0pLFxuICBjb21wb25lbnRUeXBlOiBzdHJpbmcsICAgICAgICAgIC8vIGVkaXQgY29tcG9uZW50IHR5cGUgW3RleHQvbnVtYmVyL2Zsb2F0L3NlbGVjdC9ib29sZWFuL2RhdGVdXG4gIHZhbHVlUmVuZGVyOiBmdW5jLCAgICAgICAgICAgICAgLy8gY3VzdG9tIHJlbmRlcmVyIGZvciB0aGUgdmFsdWUsIGRhdGEgYXMgcGFyYW1ldGVyXG4gIGVkaXRWYWx1ZVJlbmRlcjogZnVuYywgICAgICAgICAgLy8gY3VzdG9tIHJlbmRlcmVyIGZvciB0aGUgZWRpdCB2YWx1ZSwgZGF0YSBhcyBwYXJhbWV0ZXJcbiAgY3JlYXRlVmFsdWVSZW5kZXI6IGZ1bmMsICAgICAgICAvLyBjdXN0b20gcmVuZGVyZXIgZm9yIHRoZSBjcmVhdGUgdmFsdWUsIGRhdGEgYXMgcGFyYW1ldGVyXG4gIGZpbHRlclZhbHVlUmVuZGVyOiBmdW5jLCAgICAgICAgLy8gY3VzdG9tIHJlbmRlcmVyIGZvciB0aGUgZmlsdGVyIHZhbHVlLCBkYXRhIGFzIHBhcmFtZXRlclxuICBjZWxsOiBmdW5jLCAgICAgICAgICAgICAgICAgICAgIC8vIG92ZXJyaWRlIGNlbGwgcmVuZGVyZXIsIHJvd0luZGV4IGFzIHBhcmFtZXRlclxuICBjZWxsRWRpdDogZnVuYywgICAgICAgICAgICAgICAgIC8vIG92ZXJyaWRlIGNlbGxFZGl0IHJlbmRlcmVyLCByb3dJbmRleCBhcyBwYXJhbWV0ZXJcbiAgY2VsbENyZWF0ZTogZnVuYywgICAgICAgICAgICAgICAvLyBvdmVycmlkZSBjZWxsQ3JlYXRlIHJlbmRlcmVyLCByb3dJbmRleCBhcyBwYXJhbWV0ZXJcbiAgY2VsbEZpbHRlcjogZnVuYywgICAgICAgICAgICAgICAvLyBvdmVycmlkZSBjZWxsRmlsdGVyIHJlbmRlcmVyLCByb3dJbmRleCBhcyBwYXJhbWV0ZXJcbiAgcmVuZGVyQ29tcG9uZW50UHJvcHM6IG9iamVjdCwgICAvLyBhZGRpdGlvbmFsIHByb3BzIHRvIHRoZSByZW5kZXIgY29tcG9uZW50XG4gIGVkaXRDb21wb25lbnRQcm9wczogb2JqZWN0LCAgICAgLy8gYWRkaXRpb25hbCBwcm9wcyB0byB0aGUgZWRpdCBjb21wb25lbnRcbiAgY3JlYXRlQ29tcG9uZW50UHJvcHM6IG9iamVjdCwgICAvLyBhZGRpdGlvbmFsIHByb3BzIHRvIHRoZSBjcmVhdGUgY29tcG9uZW50XG4gIGZpbHRlckNvbXBvbmVudFByb3BzOiBvYmplY3QsICAgLy8gYWRkaXRpb25hbCBwcm9wcyB0byB0aGUgZmlsdGVyIGNvbXBvbmVudFxuICB3aWR0aDogbnVtYmVyLFxuICBtaW5XaWR0aDogbnVtYmVyLFxuICBtYXhXaWR0aDogbnVtYmVyLFxuICBhbGlnbjogc3RyaW5nLCAgICAgICAgICAgICAgICAgIC8vIHZlcnRpY2FsIGNlbGwgYWxpZ25tZW50LCBkZWZhdWx0cyB0byAnbGVmdCdcbiAgZml4ZWQ6IGJvb2wsICAgICAgICAgICAgICAgICAgICAvLyBpcyBjb2x1bW4gZml4ZWRcbiAgYWxsb3dDZWxsc1JlY3ljbGluZzogYm9vbCwgICAgICAvLyBhbGxvdyBjZWxscyB0byBiZSByZWN5Y2xlZCBmb3IgYmV0dGVyIGhvcml6b250YWwgc2Nyb2xsaW5nIHBlcmZcbiAgZGlzYWJsZVJlc2l6aW5nOiBib29sLCAgICAgICAgICAvLyBkaXNhYmxlIGNvbHVtbiByZXNpemluZ1xuICBkaXNhYmxlRWRpdGluZzogYm9vbCwgICAgICAgICAgIC8vIGRpc2FibGUgaW5wdXQgY29tcG9uZW50IChtYWtlIHJlYWQtb25seSkgd2hlbiBlZGl0aW5nL2NyZWF0aW5nXG4gIGRpc2FibGVTb3J0aW5nOiBib29sLCAgICAgICAgICAgLy8gZGlzYWJsZSBmaWx0ZXJpbmcgb24gdGhpcyBjb2x1bW5cbiAgZGlzYWJsZUVkaXRpbmdPblZhbHVlTWF0Y2g6IHNoYXBlKHsgLy8gZGlzYWJsZSBlZGl0aW5nL2NyZWF0aW5nIGlucHV0IHdoZW4gb3RoZXIgY29sdW1ucyB2YWx1ZSBtYXRjaFxuICAgIG1hdGNoVmFsdWVLZXlQYXRoOiBhcnJheSxcbiAgICBtYXRjaFZhbHVlOiBhbnksXG4gIH0pLFxuICBvblZhbHVlTWF0Y2hDaGFuZ2VWYWx1ZTogc2hhcGUoeyAvLyBDaGFuZ2Ugb3RoZXIgY29sdW1uIHZhbHVlIHdoZW4gZGF0YSBtYXRjaGVzXG4gICAgbWF0Y2hWYWx1ZTogYW55LFxuICAgIG5ld1ZhbHVlS2V5UGF0aDogYXJyYXksXG4gICAgbmV3VmFsdWU6IGFueSxcbiAgfSksXG4gIGZsZXhHcm93OiBudW1iZXIsXG4gIHZhbHVlRW1wdHlDaGVja2VyOiBmdW5jLCAgICAgICAgLy8gb3ZlcnJpZGUgZnVuY3Rpb24gdGhhdCBjaGVja3MgaWYgdmFsdWUgaXMgY29uc2lkZXJlZCBhcyBlbXB0eVxuICBzb3J0VmFsdWVHZXR0ZXI6IGZ1bmMsICAgICAgICAgIC8vIG92ZXJyaWRlIHNvcnQgdmFsdWUgZ2V0dGVyLCBkZWZhdWx0cyB0byBnZXRJbih2YWx1ZUtleVBhdGgpXG4gIHNvcnRDb21wYXJhdG9yOiBmdW5jLCAgICAgICAgICAgLy8gb3ZlcnJpZGUgc29ydCBjb21wYXJhdG9yIGZ1bmN0aW9uLCBkZWZhdWx0IHNvcnRzIGJ5IHZhbHVlVHlwZVxuICBmaWx0ZXJNYXRjaGVyOiBmdW5jLCAgICAgICAgICAgIC8vIG92ZXJyaWRlIGZpbHRlciBtYXRjaGVyIGZ1bmN0aW9uLCB0aGF0IGRlZmluZWQgd2hlbiBmaWx0ZXIgbWF0Y2hlcyBkYXRhXG4gIGRlZmF1bHRWYWx1ZTogYW55LCAgICAgICAgICAgICAgLy8gZGVmYXVsdCB2YWx1ZSBmb3IgdGhlIGNvbHVtbiB3aGVuIGNyZWF0aW5nIG5ldyBpdGVtXG4gIGlzUmVxdWlyZWQ6IGJvb2wsICAgICAgICAgICAgICAgLy8gaXMgY29sdW1uIHZhbHVlIHJlcXVpcmVkXG4gIGlzSGlkZGVuOiBib29sLCAgICAgICAgICAgICAgICAgLy8gaXMgY29sdW1uIGhpZGRlbiBieSBkZWZhdWx0XG4gIG9uRWRpdFZhbHVlQ2hhbmdlOiBmdW5jLCAgICAgICAgLy8gY2FsbGJhY2sgd2l0aCAodmFsdWUsIHZhbHVlS2V5UGF0aCwgcm93SW5kZXgsIGRhdGFJZClcbiAgb25DcmVhdGVWYWx1ZUNoYW5nZTogZnVuYywgICAgICAvLyBjYWxsYmFjIHdpdGggKHZhbHVlLCB2YWx1ZUtleVBhdGgsIHJvd0luZGV4KVxuICBvbkNyZWF0ZUJsdXI6IGZ1bmMsICAgICAgICAgICAgIC8vIGNhbGxiYWNrIHdpdGggKHZhbHVlLCByb3dJbmRleClcbiAgb25FZGl0Qmx1cjogZnVuYywgICAgICAgICAgICAgICAvLyBjYWxsYmFjayB3aXRoICh2YWx1ZSwgcm93SW5kZXgsIGRhdGFJZClcbiAgc2VsZWN0Q29tcG9uZW50T3B0aW9uczogYXJyYXlPZihzaGFwZSh7XG4gICAgdmFsdWU6IG9uZU9mVHlwZShbbnVtYmVyLCBzdHJpbmcsIGJvb2xdKS5pc1JlcXVpcmVkLFxuICAgIGxhYmVsOiBvbmVPZlR5cGUoW251bWJlciwgc3RyaW5nXSkuaXNSZXF1aXJlZCxcbiAgfSkpLFxuICBzZWxlY3RDb21wb25lbnRUcmFuc2xhdGlvbnM6IHNoYXBlKHsgLy8gY3VzdG9taXplIHNlbGVjdCBjb21wb25lbnRzIHBsYWNlaG9sZGVyIGFuZCBub1Jlc3VsdHMgdGV4dHMuXG4gICAgcGxhY2Vob2xkZXI6IHN0cmluZyxcbiAgICBub1Jlc3VsdHNUZXh0OiBzdHJpbmcsXG4gIH0pLFxufSk7XG5cbmV4cG9ydCBjb25zdCBwcm9wVHlwZXMgPSB7XG4gIGNoaWxkcmVuOiBub2RlLFxuICAvLyBBcHAgcHJvcHNcbiAgaW50bDogb2JqZWN0LmlzUmVxdWlyZWQsXG4gIC8vIEFjdGlvbiBwcm9wc1xuICBhZGROZXdJdGVtOiBmdW5jLmlzUmVxdWlyZWQsXG4gIHJlbW92ZU5ld0l0ZW06IGZ1bmMuaXNSZXF1aXJlZCxcbiAgY3JlYXRlOiBmdW5jLmlzUmVxdWlyZWQsXG4gIGVkaXQ6IGZ1bmMuaXNSZXF1aXJlZCxcbiAgcmVtb3ZlOiBmdW5jLmlzUmVxdWlyZWQsXG4gIHNhdmU6IGZ1bmMuaXNSZXF1aXJlZCxcbiAgY2FuY2VsOiBmdW5jLmlzUmVxdWlyZWQsXG4gIHNvcnRDaGFuZ2U6IGZ1bmMuaXNSZXF1aXJlZCxcbiAgcmVzaXplQ29sdW1uOiBmdW5jLmlzUmVxdWlyZWQsXG4gIGludmFsaWRhdGU6IGZ1bmMuaXNSZXF1aXJlZCxcbiAgY2VsbFNlbGVjdGlvbkNoYW5nZTogZnVuYy5pc1JlcXVpcmVkLFxuICBpdGVtU2VsZWN0aW9uQ2hhbmdlOiBmdW5jLmlzUmVxdWlyZWQsXG4gIHRvZ2dsZUZpbHRlcmluZzogZnVuYy5pc1JlcXVpcmVkLFxuICBlZGl0Q2VsbFZhbHVlQ2hhbmdlOiBmdW5jLmlzUmVxdWlyZWQsXG4gIGNyZWF0ZUNlbGxWYWx1ZUNoYW5nZTogZnVuYy5pc1JlcXVpcmVkLFxuICBmaWx0ZXJDZWxsVmFsdWVDaGFuZ2U6IGZ1bmMuaXNSZXF1aXJlZCxcbiAgZWRpdENlbGxWYWx1ZVZhbGlkYXRlOiBmdW5jLmlzUmVxdWlyZWQsXG4gIGNyZWF0ZUNlbGxWYWx1ZVZhbGlkYXRlOiBmdW5jLmlzUmVxdWlyZWQsXG4gIHZhbGlkYXRlRWRpdGVkUm93czogZnVuYy5pc1JlcXVpcmVkLFxuICB2YWxpZGF0ZUNyZWF0ZWRSb3dzOiBmdW5jLmlzUmVxdWlyZWQsXG4gIC8vIFN0YXRlIHByb3BzXG4gIGlzQnVzeTogYm9vbC5pc1JlcXVpcmVkLFxuICBpc0VkaXRpbmc6IGJvb2wuaXNSZXF1aXJlZCxcbiAgaXNDcmVhdGluZzogYm9vbC5pc1JlcXVpcmVkLFxuICBpc0ZpbHRlcmluZzogYm9vbC5pc1JlcXVpcmVkLFxuICBzb3J0Q29sdW1uOiBvbmVPZlR5cGUoW1xuICAgIHN0cmluZyxcbiAgICBudW1iZXIsXG4gIF0pLFxuICBzb3J0T3JkZXI6IHN0cmluZyxcbiAgdmlzaWJsZUNvbHVtbnM6IGxpc3QuaXNSZXF1aXJlZCxcbiAgY29sdW1uV2lkdGhzOiBtYXAuaXNSZXF1aXJlZCxcbiAgc2VsZWN0ZWRDZWxsOiBtYXAuaXNSZXF1aXJlZCxcbiAgc2VsZWN0ZWRJdGVtczogbGlzdC5pc1JlcXVpcmVkLFxuICBkYXRhOiBsaXN0LmlzUmVxdWlyZWQsXG4gIGVkaXREYXRhOiBtYXAuaXNSZXF1aXJlZCxcbiAgY3JlYXRlRGF0YTogbGlzdC5pc1JlcXVpcmVkLFxuICBmaWx0ZXJEYXRhOiBtYXAuaXNSZXF1aXJlZCxcbiAgY2VsbE1lc3NhZ2VzOiBtYXAuaXNSZXF1aXJlZCxcbiAgY3JlYXRlQ2VsbE1lc3NhZ2VzOiBtYXAuaXNSZXF1aXJlZCxcbiAgbGFuZ3VhZ2U6IHN0cmluZy5pc1JlcXVpcmVkLFxuICByZWdpb246IHN0cmluZy5pc1JlcXVpcmVkLFxuICB0aG91c2FuZFNlcGFyYXRvcjogc3RyaW5nLmlzUmVxdWlyZWQsXG4gIGRlY2ltYWxTZXBhcmF0b3I6IHN0cmluZy5pc1JlcXVpcmVkLFxuICBhbGxEYXRhU2l6ZTogbnVtYmVyLmlzUmVxdWlyZWQsXG4gIC8vIFJlcXVpcmVkIGNvbXBvbmVudCBwcm9wZXJ0aWVzXG4gIGdyaWQ6IGdyaWRTaGFwZS5pc1JlcXVpcmVkLFxuICBjb2x1bW5zOiBhcnJheU9mKGNvbHVtblNoYXBlLmlzUmVxdWlyZWQpLmlzUmVxdWlyZWQsXG4gIC8vIE9wdGlvbmFsIGNvbXBvbmVudCBwcm9wZXJ0aWVzXG4gIHJvd3NDb3VudDogbnVtYmVyLFxuICBncmlkSGVhZGVyOiBub2RlLFxuICBhY3Rpb25CYXI6IG5vZGUsXG4gIGFjdGlvbkJhckxlZnQ6IG5vZGUsXG4gIGNlbGxTZWxlY3Q6IGJvb2wsXG4gIGRpc2FibGVEcm9wZG93bjogYm9vbCwgICAgICAgICAgICAgIC8vIERvbid0IHVzZSBkcm9wZG93biBtZW51IGluIHRoZSBhY3Rpb24gYmFyXG4gIGRpc2FibGVGaWx0ZXJpbmdDb250cm9sczogYm9vbCwgICAgIC8vIERvbid0IGRpc3BsYXkgdGhlIGZpbHRlcmluZyBjb250cm9scyAob25seSB2YWxpZCBpZiBkaXNhYmxlRHJvcGRvd24gaXMgdHJ1ZSlcbiAgZHJvcGRvd25NZW51SXRlbXM6IGFycmF5T2Yoc2hhcGUoe1xuICAgIGlkOiBzdHJpbmcsXG4gICAgdGl0bGU6IG5vZGUsXG4gICAgaWNvbjogbm9kZSxcbiAgICBvbkNsaWNrOiBmdW5jLFxuICAgIGRpc2FibGVkOiBvbmVPZlR5cGUoW2Jvb2wsIGZ1bmNdKSxcbiAgfSkpLFxuICBpbmxpbmVFZGl0OiBib29sLFxuICBpbmxpbmVBZGQ6IGJvb2wsXG4gIGZpbHRlcmluZzogYm9vbCxcbiAgcmVtb3Zpbmc6IGJvb2wsXG4gIGNvbHVtblNldHRpbmdzOiBib29sLFxuICByb3dTZWxlY3Q6IGJvb2wsXG4gIHJvd1NlbGVjdENoZWNrYm94Q29sdW1uOiBib29sLFxuICBtdWx0aVNlbGVjdDogYm9vbCxcbiAgc2VsZWN0Q29tcG9uZW50T3B0aW9uczogbWFwT2YoYXJyYXlPZihzaGFwZSh7ICAvLyBPcHRpb25zIGRhdGEgZm9yIHRoZSByZWFjdC1zZWxlY3QgY29tcG9uZW50c1xuICAgIHZhbHVlOiBvbmVPZlR5cGUoW251bWJlciwgc3RyaW5nLCBib29sXSkuaXNSZXF1aXJlZCxcbiAgICBsYWJlbDogb25lT2ZUeXBlKFtudW1iZXIsIHN0cmluZ10pLmlzUmVxdWlyZWQsXG4gIH0pKSksXG4gIHNlbGVjdENvbXBvbmVudFRyYW5zbGF0aW9uczogc2hhcGUoeyAgLy8gT3B0aW9ucyBmb3IgcmVhY3Qtc2VsZWN0IHRleHQgdHJhbnNsYXRpb25zXG4gICAgcGxhY2Vob2xkZXI6IHN0cmluZy5pc1JlcXVpcmVkLFxuICAgIG5vUmVzdWx0c1RleHQ6IHN0cmluZy5pc1JlcXVpcmVkLFxuICB9KSxcbiAgZGlzYWJsZUFjdGlvbnM6IGJvb2wsICAgICAgICAgICAgICAgLy8gRGlzYWJsZSBhY3Rpb25zIGluIHRoZSBhY3Rpb24gYmFyXG4gIGRpc2FibGVBY3Rpb25zTWVzc2FnZTogc2hhcGUoe1xuICAgIG1lc3NhZ2VJZDogc3RyaW5nLFxuICAgIG1lc3NhZ2VWYWx1ZXM6IHNoYXBlKHt9KSxcbiAgfSksXG4gIGRpc2FibGVBY3Rpb25CYXI6IGJvb2wsXG4gIGRpc2FibGVBY3Rpb25TYXZlOiBib29sLFxuICBlbmFibGVBcnJvd05hdmlnYXRpb246IGJvb2wsXG4gIG9uU2F2ZTogZnVuYyxcbiAgb25SZW1vdmU6IGZ1bmMsXG4gIG9uQ2FuY2VsOiBmdW5jLFxuICBvbkFkZENsaWNrOiBmdW5jLFxuICBvbkVkaXRDbGljazogZnVuYyxcbiAgdGFiSW5kZXg6IG51bWJlciwgICAgICAgICAgICAgICAgICAgLy8gdGFiSW5kZXggdmFsdWUgZm9yIGlucHV0cyBpbiBjZWxsc1xuICBleHRyYUNvbHVtbjogc2hhcGUoeyAgICAgICAgICAgICAgICAvLyBFeHRyYSBmaXhlZCBjb2x1bW4gdGhhdCBjYW4ndCBiZSByZS1vcmRlcmVkIG9yIGhpZGRlblxuICAgIHdpZHRoOiBzdHJpbmcsXG4gICAgdmFsdWVSZW5kZXI6IGZ1bmMsXG4gICAgY2VsbEVkaXQ6IGZ1bmMsXG4gICAgY2VsbENyZWF0ZTogZnVuYyxcbiAgICBjZWxsRmlsdGVyOiBmdW5jLFxuICAgIGlzUmVzaXphYmxlOiBib29sLFxuICB9KSxcbiAgY29udGV4dE1lbnVJdGVtczogYXJyYXlPZihzaGFwZSh7ICAgLy8gQ29udGV4dCBtZW51IGl0ZW1zIHRvIGRpc3BsYXkgd2hlbiByb3cgaXMgcmlnaHQtY2xpY2tlZFxuICAgIHZhbHVlOiBub2RlLFxuICAgIG9uQ2xpY2s6IGZ1bmMsXG4gICAgdGl0bGU6IHN0cmluZyxcbiAgICBoZWFkZXI6IGJvb2wsXG4gICAgZGlzYWJsZWQ6IG9uZU9mVHlwZShbYm9vbCwgZnVuY10pLFxuICAgIGRpdmlkZXI6IGJvb2wsXG4gIH0pKSxcbiAgLy8gRml4ZWQgZGF0YSB0YWJsZSBidWlsdC1pbiBmZWF0dXJlc1xuICBoZWFkZXJIZWlnaHQ6IG51bWJlcixcbiAgZmlsdGVyUm93SGVpZ2h0OiBudW1iZXIsXG4gIHJvd0hlaWdodDogbnVtYmVyLFxuICBjb250YWluZXJTdHlsZTogb2JqZWN0LFxuICBzY3JvbGxUb0NvbHVtbjogbnVtYmVyLFxuICBzY3JvbGxUb3A6IG51bWJlcixcbiAgc2Nyb2xsVG9Sb3c6IG51bWJlcixcbiAgb25Sb3dDbGljazogZnVuYyxcbiAgb25Sb3dEb3VibGVDbGljazogZnVuYyxcbiAgb25Sb3dNb3VzZURvd246IGZ1bmMsXG4gIG9uUm93TW91c2VFbnRlcjogZnVuYyxcbiAgb25Sb3dNb3VzZUxlYXZlOiBmdW5jLFxuICBvblNjcm9sbFN0YXJ0OiBmdW5jLFxuICBvblNjcm9sbEVuZDogZnVuYyxcbiAgcm93Q2xhc3NOYW1lR2V0dGVyOiBmdW5jLFxuICByb3dIZWlnaHRHZXR0ZXI6IGZ1bmMsXG4gIG9uQ29udGVudEhlaWdodENoYW5nZTogZnVuYyxcbiAgY2xhc3NOYW1lOiBzdHJpbmcsXG4gIGZvY3VzVHlwZTogbWFwLmlzUmVxdWlyZWQsXG59O1xuXG4vKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4sIHByZWZlci10ZW1wbGF0ZSwgcmVhY3Qvbm8tdW51c2VkLXByb3AtdHlwZXMsIHJlYWN0L2ZvcmJpZC1wcm9wLXR5cGVzICovXG5cbmV4cG9ydCBjb25zdCBkZWZhdWx0UHJvcHMgPSB7XG4gIGNlbGxTZWxlY3Q6IGZhbHNlLFxuICBjb2x1bW5TZXR0aW5nczogZmFsc2UsXG4gIGNoaWxkcmVuOiB1bmRlZmluZWQsXG4gIGNvbnRhaW5lclN0eWxlOiB7fSxcbiAgZGlzYWJsZUFjdGlvblNhdmU6IGZhbHNlLFxuICBlbmFibGVBcnJvd05hdmlnYXRpb246IGZhbHNlLFxuICBoZWFkZXJIZWlnaHQ6IDQwLFxuICBmaWx0ZXJSb3dIZWlnaHQ6IDQwLFxuICByb3dIZWlnaHQ6IDQwLFxuICBvblNhdmU6ICgpID0+IHt9LFxuICBvblJlbW92ZTogKCkgPT4ge30sXG4gIG9uQ2FuY2VsOiAoKSA9PiB7fSxcbiAgdGFiSW5kZXg6IDEsXG4gIGRpc2FibGVGaWx0ZXJpbmdDb250cm9sczogZmFsc2UsXG4gIGNsYXNzTmFtZTogJycsXG59O1xuIl19