var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

import React from 'react';
import { FloatingSelectPortal, FloatingSelectPortalCreatable } from '@opuscapita/react-floating-select';

export var selectRender = function selectRender(selectProps) {
  return React.createElement(FloatingSelectPortal, selectProps);
};

export var creatableSelectRender = function creatableSelectRender(selectProps) {
  return React.createElement(FloatingSelectPortalCreatable, selectProps);
};

export default {
  cellEdit: function cellEdit(col, column, rowIndex, tabIndex, gridId, selectOptions, selectTranslations, editValueParser, functions, getComponentDisabledState) {
    var cellName = 'edit';
    var opts = col.editSelectOptionsMod && selectOptions ? col.editSelectOptionsMod(selectOptions.slice(), rowIndex, col) : selectOptions;
    var fsProps = _extends({
      name: 'ocDatagridEditInput-' + gridId + '-' + column.columnKey + '-' + rowIndex,
      options: opts,
      value: functions.getItemValue(rowIndex, col, { selectOptions: selectOptions }),
      onChange: functions.onCellValueChange(rowIndex, col, editValueParser),
      onBlur: functions.onCellBlur(rowIndex, col),
      onFocus: functions.onCellFocus(cellName, col.componentType, rowIndex, column.columnKey),
      onKeyDown: functions.onCellKeyDown(rowIndex, col),
      isSearchable: selectOptions && selectOptions.length > 9,
      isClearable: !col.isRequired,
      backSpaceRemovesValue: false,
      tabSelectsValue: false,
      openMenuOnFocus: false,
      ref: functions.handleCellRef(rowIndex, col),
      isDisabled: getComponentDisabledState(rowIndex, col, cellName),
      tabIndex: tabIndex
    }, col.editComponentProps, selectTranslations);

    if (col.isCreatableSelect) return creatableSelectRender(_extends({}, fsProps));
    return selectRender(_extends({}, fsProps));
  },
  cellCreate: function cellCreate(col, column, rowIndex, tabIndex, gridId, selectOptions, selectTranslations, editValueParser, functions, getComponentDisabledState) {
    var cellName = 'create';
    var opts = col.createSelectOptionsMod && selectOptions ? col.createSelectOptionsMod(selectOptions.slice(), rowIndex, col) : selectOptions;
    var fsProps = _extends({
      name: 'ocDatagridCreateInput-' + gridId + '-' + column.columnKey + '-' + rowIndex,
      options: opts,
      value: functions.getItemValue(rowIndex, col, { selectOptions: selectOptions }),
      onChange: functions.onCellValueChange(rowIndex, col, editValueParser),
      onBlur: functions.onCellBlur(rowIndex, col),
      onKeyDown: functions.onCellKeyDown(rowIndex, col),
      onFocus: functions.onCellFocus(cellName, col.componentType, rowIndex, column.columnKey),
      isSearchable: selectOptions && selectOptions.length > 9,
      isClearable: !col.isRequired,
      backspaceRemovesValue: false,
      tabSelectsValue: false,
      openMenuOnFocus: false,
      ref: functions.handleCellRef(rowIndex, col),
      isDisabled: getComponentDisabledState(rowIndex, col, cellName),
      tabIndex: tabIndex
    }, col.createComponentProps, selectTranslations);

    if (col.isCreatableSelect) return creatableSelectRender(_extends({}, fsProps));
    return selectRender(_extends({}, fsProps));
  },
  cellFilter: function cellFilter(col, column, tabIndex, gridId, selectOptions, selectTranslations, editValueParser, functions) {
    var opts = col.filterSelectOptionsMod && selectOptions ? col.filterSelectOptionsMod(selectOptions.slice(), col) : selectOptions;
    var fsProps = _extends({
      name: 'ocDatagridFilterInput-' + gridId + '-' + column.columnKey,
      options: opts,
      value: functions.getItemValue(col, { selectOptions: selectOptions }),
      onChange: functions.onCellValueChange(col, editValueParser),
      isSearchable: selectOptions && selectOptions.length > 9,
      isClearable: true,
      tabSelectsValue: false,
      tabIndex: tabIndex
    }, col.filterComponentProps, selectTranslations);

    return selectRender(_extends({}, fsProps));
  }
};
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3NyYy9kYXRhZ3JpZC9jb2x1bW4tc2VydmljZS9jb2x1bW4tdHlwZXMvc2VsZWN0LXJlbmRlcmVycy5qc3giXSwibmFtZXMiOlsiUmVhY3QiLCJGbG9hdGluZ1NlbGVjdFBvcnRhbCIsIkZsb2F0aW5nU2VsZWN0UG9ydGFsQ3JlYXRhYmxlIiwic2VsZWN0UmVuZGVyIiwic2VsZWN0UHJvcHMiLCJjcmVhdGFibGVTZWxlY3RSZW5kZXIiLCJjZWxsRWRpdCIsImNvbCIsImNvbHVtbiIsInJvd0luZGV4IiwidGFiSW5kZXgiLCJncmlkSWQiLCJzZWxlY3RPcHRpb25zIiwic2VsZWN0VHJhbnNsYXRpb25zIiwiZWRpdFZhbHVlUGFyc2VyIiwiZnVuY3Rpb25zIiwiZ2V0Q29tcG9uZW50RGlzYWJsZWRTdGF0ZSIsImNlbGxOYW1lIiwib3B0cyIsImVkaXRTZWxlY3RPcHRpb25zTW9kIiwic2xpY2UiLCJmc1Byb3BzIiwibmFtZSIsImNvbHVtbktleSIsIm9wdGlvbnMiLCJ2YWx1ZSIsImdldEl0ZW1WYWx1ZSIsIm9uQ2hhbmdlIiwib25DZWxsVmFsdWVDaGFuZ2UiLCJvbkJsdXIiLCJvbkNlbGxCbHVyIiwib25Gb2N1cyIsIm9uQ2VsbEZvY3VzIiwiY29tcG9uZW50VHlwZSIsIm9uS2V5RG93biIsIm9uQ2VsbEtleURvd24iLCJpc1NlYXJjaGFibGUiLCJsZW5ndGgiLCJpc0NsZWFyYWJsZSIsImlzUmVxdWlyZWQiLCJiYWNrU3BhY2VSZW1vdmVzVmFsdWUiLCJ0YWJTZWxlY3RzVmFsdWUiLCJvcGVuTWVudU9uRm9jdXMiLCJyZWYiLCJoYW5kbGVDZWxsUmVmIiwiaXNEaXNhYmxlZCIsImVkaXRDb21wb25lbnRQcm9wcyIsImlzQ3JlYXRhYmxlU2VsZWN0IiwiY2VsbENyZWF0ZSIsImNyZWF0ZVNlbGVjdE9wdGlvbnNNb2QiLCJiYWNrc3BhY2VSZW1vdmVzVmFsdWUiLCJjcmVhdGVDb21wb25lbnRQcm9wcyIsImNlbGxGaWx0ZXIiLCJm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WEMsU0F6RlcsRUEwRlg7QUFDQSxRQUFNRyxPQUFPWCxJQUFJOEMsc0JBQUosSUFBOEJ6QyxhQUE5QixHQUNYTCxJQUFJOEMsc0JBQUosQ0FBMkJ6QyxjQUFjUSxLQUFkLEVBQTNCLEVBQWtEYixHQUFsRCxDQURXLEdBRVhLLGFBRkY7QUFHQSxRQUFNUztBQUNKQyx1Q0FBK0JYLE1BQS9CLFNBQXlDSCxPQUFPZSxTQUQ1QztBQUVKQyxlQUFTTixJQUZMO0FBR0pPLGFBQU9WLFVBQVVXLFlBQVYsQ0FBdUJuQixHQUF2QixFQUE0QixFQUFFSyw0QkFBRixFQUE1QixDQUhIO0FBSUplLGdCQUFVWixVQUFVYSxpQkFBVixDQUE0QnJCLEdBQTVCLEVBQWlDTyxlQUFqQyxDQUpOO0FBS0pzQixvQkFBY3hCLGlCQUFrQkEsY0FBY3lCLE1BQWQsR0FBdUIsQ0FMbkQ7QUFNSkMsbUJBQWEsSUFOVDtBQU9KRyx1QkFBaUIsS0FQYjtBQVFKL0I7QUFSSSxPQVNESCxJQUFJK0Msb0JBVEgsRUFVRHpDLGtCQVZDLENBQU47O0FBYUEsV0FBT1YsMEJBQWtCa0IsT0FBbEIsRUFBUDtBQUNEO0FBNUdZLENBQWYiLCJmaWxlIjoic2VsZWN0LXJlbmRlcmVycy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQge1xuICBGbG9hdGluZ1NlbGVjdFBvcnRhbCxcbiAgRmxvYXRpbmdTZWxlY3RQb3J0YWxDcmVhdGFibGUsXG59IGZyb20gJ0BvcHVzY2FwaXRhL3JlYWN0LWZsb2F0aW5nLXNlbGVjdCc7XG5cbmV4cG9ydCBjb25zdCBzZWxlY3RSZW5kZXIgPSBzZWxlY3RQcm9wcyA9PiAoXG4gIDxGbG9hdGluZ1NlbGVjdFBvcnRhbCB7Li4uc2VsZWN0UHJvcHN9IC8+XG4pO1xuXG5leHBvcnQgY29uc3QgY3JlYXRhYmxlU2VsZWN0UmVuZGVyID0gc2VsZWN0UHJvcHMgPT4gKFxuICA8RmxvYXRpbmdTZWxlY3RQb3J0YWxDcmVhdGFibGUgey4uLnNlbGVjdFByb3BzfSAvPlxuKTtcblxuZXhwb3J0IGRlZmF1bHQge1xuICBjZWxsRWRpdChcbiAgICBjb2wsXG4gICAgY29sdW1uLFxuICAgIHJvd0luZGV4LFxuICAgIHRhYkluZGV4LFxuICAgIGdyaWRJZCxcbiAgICBzZWxlY3RPcHRpb25zLFxuICAgIHNlbGVjdFRyYW5zbGF0aW9ucyxcbiAgICBlZGl0VmFsdWVQYXJzZXIsXG4gICAgZnVuY3Rpb25zLFxuICAgIGdldENvbXBvbmVudERpc2FibGVkU3RhdGUsXG4gICkge1xuICAgIGNvbnN0IGNlbGxOYW1lID0gJ2VkaXQnO1xuICAgIGNvbnN0IG9wdHMgPSBjb2wuZWRpdFNlbGVjdE9wdGlvbnNNb2QgJiYgc2VsZWN0T3B0aW9ucyA/XG4gICAgICBjb2wuZWRpdFNlbGVjdE9wdGlvbnNNb2Qoc2VsZWN0T3B0aW9ucy5zbGljZSgpLCByb3dJbmRleCwgY29sKSA6XG4gICAgICBzZWxlY3RPcHRpb25zO1xuICAgIGNvbnN0IGZzUHJvcHMgPSB7XG4gICAgICBuYW1lOiBgb2NEYXRhZ3JpZEVkaXRJbnB1dC0ke2dyaWRJZH0tJHtjb2x1bW4uY29sdW1uS2V5fS0ke3Jvd0luZGV4fWAsXG4gICAgICBvcHRpb25zOiBvcHRzLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9ucy5nZXRJdGVtVmFsdWUocm93SW5kZXgsIGNvbCwgeyBzZWxlY3RPcHRpb25zIH0pLFxuICAgICAgb25DaGFuZ2U6IGZ1bmN0aW9ucy5vbkNlbGxWYWx1ZUNoYW5nZShyb3dJbmRleCwgY29sLCBlZGl0VmFsdWVQYXJzZXIpLFxuICAgICAgb25CbHVyOiBmdW5jdGlvbnMub25DZWxsQmx1cihyb3dJbmRleCwgY29sKSxcbiAgICAgIG9uRm9jdXM6IGZ1bmN0aW9ucy5vbkNlbGxGb2N1cyhjZWxsTmFtZSwgY29sLmNvbXBvbmVudFR5cGUsIHJvd0luZGV4LCBjb2x1bW4uY29sdW1uS2V5KSxcbiAgICAgIG9uS2V5RG93bjogZnVuY3Rpb25zLm9uQ2VsbEtleURvd24ocm93SW5kZXgsIGNvbCksXG4gICAgICBpc1NlYXJjaGFibGU6IHNlbGVjdE9wdGlvbnMgJiYgKHNlbGVjdE9wdGlvbnMubGVuZ3RoID4gOSksXG4gICAgICBpc0NsZWFyYWJsZTogIWNvbC5pc1JlcXVpcmVkLFxuICAgICAgYmFja1NwYWNlUmVtb3Zlc1ZhbHVlOiBmYWxzZSxcbiAgICAgIHRhYlNlbGVjdHNWYWx1ZTogZmFsc2UsXG4gICAgICBvcGVuTWVudU9uRm9jdXM6IGZhbHNlLFxuICAgICAgcmVmOiBmdW5jdGlvbnMuaGFuZGxlQ2VsbFJlZihyb3dJbmRleCwgY29sKSxcbiAgICAgIGlzRGlzYWJsZWQ6IGdldENvbXBvbmVudERpc2FibGVkU3RhdGUocm93SW5kZXgsIGNvbCwgY2VsbE5hbWUpLFxuICAgICAgdGFiSW5kZXgsXG4gICAgICAuLi5jb2wuZWRpdENvbXBvbmVudFByb3BzLFxuICAgICAgLi4uc2VsZWN0VHJhbnNsYXRpb25zLFxuICAgIH07XG5cbiAgICBpZiAoY29sLmlzQ3JlYXRhYmxlU2VsZWN0KSByZXR1cm4gY3JlYXRhYmxlU2VsZWN0UmVuZGVyKHsgLi4uZnNQcm9wcyB9KTtcbiAgICByZXR1cm4gc2VsZWN0UmVuZGVyKHsgLi4uZnNQcm9wcyB9KTtcbiAgfSxcblxuICBjZWxsQ3JlYXRlKFxuICAgIGNvbCxcbiAgICBjb2x1bW4sXG4gICAgcm93SW5kZXgsXG4gICAgdGFiSW5kZXgsXG4gICAgZ3JpZElkLFxuICAgIHNlbGVjdE9wdGlvbnMsXG4gICAgc2VsZWN0VHJhbnNsYXRpb25zLFxuICAgIGVkaXRWYWx1ZVBhcnNlcixcbiAgICBmdW5jdGlvbnMsXG4gICAgZ2V0Q29tcG9uZW50RGlzYWJsZWRTdGF0ZSxcbiAgKSB7XG4gICAgY29uc3QgY2VsbE5hbWUgPSAnY3JlYXRlJztcbiAgICBjb25zdCBvcHRzID0gY29sLmNyZWF0ZVNlbGVjdE9wdGlvbnNNb2QgJiYgc2VsZWN0T3B0aW9ucyA/XG4gICAgICBjb2wuY3JlYXRlU2VsZWN0T3B0aW9uc01vZChzZWxlY3RPcHRpb25zLnNsaWNlKCksIHJvd0luZGV4LCBjb2wpIDpcbiAgICAgIHNlbGVjdE9wdGlvbnM7XG4gICAgY29uc3QgZnNQcm9wcyA9IHtcbiAgICAgIG5hbWU6IGBvY0RhdGFncmlkQ3JlYXRlSW5wdXQtJHtncmlkSWR9LSR7Y29sdW1uLmNvbHVtbktleX0tJHtyb3dJbmRleH1gLFxuICAgICAgb3B0aW9uczogb3B0cyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbnMuZ2V0SXRlbVZhbHVlKHJvd0luZGV4LCBjb2wsIHsgc2VsZWN0T3B0aW9ucyB9KSxcbiAgICAgIG9uQ2hhbmdlOiBmdW5jdGlvbnMub25DZWxsVmFsdWVDaGFuZ2Uocm93SW5kZXgsIGNvbCwgZWRpdFZhbHVlUGFyc2VyKSxcbiAgICAgIG9uQmx1cjogZnVuY3Rpb25zLm9uQ2VsbEJsdXIocm93SW5kZXgsIGNvbCksXG4gICAgICBvbktleURvd246IGZ1bmN0aW9ucy5vbkNlbGxLZXlEb3duKHJvd0luZGV4LCBjb2wpLFxuICAgICAgb25Gb2N1czogZnVuY3Rpb25zLm9uQ2VsbEZvY3VzKGNlbGxOYW1lLCBjb2wuY29tcG9uZW50VHlwZSwgcm93SW5kZXgsIGNvbHVtbi5jb2x1bW5LZXkpLFxuICAgICAgaXNTZWFyY2hhYmxlOiBzZWxlY3RPcHRpb25zICYmIChzZWxlY3RPcHRpb25zLmxlbmd0aCA+IDkpLFxuICAgICAgaXNDbGVhcmFibGU6ICFjb2wuaXNSZXF1aXJlZCxcbiAgICAgIGJhY2tzcGFjZVJlbW92ZXNWYWx1ZTogZmFsc2UsXG4gICAgICB0YWJTZWxlY3RzVmFsdWU6IGZhbHNlLFxuICAgICAgb3Blbk1lbnVPbkZvY3VzOiBmYWxzZSxcbiAgICAgIHJlZjogZnVuY3Rpb25zLmhhbmRsZUNlbGxSZWYocm93SW5kZXgsIGNvbCksXG4gICAgICBpc0Rpc2FibGVkOiBnZXRDb21wb25lbnREaXNhYmxlZFN0YXRlKHJvd0luZGV4LCBjb2wsIGNlbGxOYW1lKSxcbiAgICAgIHRhYkluZGV4LFxuICAgICAgLi4uY29sLmNyZWF0ZUNvbXBvbmVudFByb3BzLFxuICAgICAgLi4uc2VsZWN0VHJhbnNsYXRpb25zLFxuICAgIH07XG5cbiAgICBpZiAoY29sLmlzQ3JlYXRhYmxlU2VsZWN0KSByZXR1cm4gY3JlYXRhYmxlU2VsZWN0UmVuZGVyKHsgLi4uZnNQcm9wcyB9KTtcbiAgICByZXR1cm4gc2VsZWN0UmVuZGVyKHsgLi4uZnNQcm9wcyB9KTtcbiAgfSxcblxuICBjZWxsRmlsdGVyKFxuICAgIGNvbCxcbiAgICBjb2x1bW4sXG4gICAgdGFiSW5kZXgsXG4gICAgZ3JpZElkLFxuICAgIHNlbGVjdE9wdGlvbnMsXG4gICAgc2VsZWN0VHJhbnNsYXRpb25zLFxuICAgIGVkaXRWYWx1ZVBhcnNlcixcbiAgICBmdW5jdGlvbnMsXG4gICkge1xuICAgIGNvbnN0IG9wdHMgPSBjb2wuZmlsdGVyU2VsZWN0T3B0aW9uc01vZCAmJiBzZWxlY3RPcHRpb25zID9cbiAgICAgIGNvbC5maWx0ZXJTZWxlY3RPcHRpb25zTW9kKHNlbGVjdE9wdGlvbnMuc2xpY2UoKSwgY29sKSA6XG4gICAgICBzZWxlY3RPcHRpb25zO1xuICAgIGNvbnN0IGZzUHJvcHMgPSB7XG4gICAgICBuYW1lOiBgb2NEYXRhZ3JpZEZpbHRlcklucHV0LSR7Z3JpZElkfS0ke2NvbHVtbi5jb2x1bW5LZXl9YCxcbiAgICAgIG9wdGlvbnM6IG9wdHMsXG4gICAgICB2YWx1ZTogZnVuY3Rpb25zLmdldEl0ZW1WYWx1ZShjb2wsIHsgc2VsZWN0T3B0aW9ucyB9KSxcbiAgICAgIG9uQ2hhbmdlOiBmdW5jdGlvbnMub25DZWxsVmFsdWVDaGFuZ2UoY29sLCBlZGl0VmFsdWVQYXJzZXIpLFxuICAgICAgaXNTZWFyY2hhYmxlOiBzZWxlY3RPcHRpb25zICYmIChzZWxlY3RPcHRpb25zLmxlbmd0aCA+IDkpLFxuICAgICAgaXNDbGVhcmFibGU6IHRydWUsXG4gICAgICB0YWJTZWxlY3RzVmFsdWU6IGZhbHNlLFxuICAgICAgdGFiSW5kZXgsXG4gICAgICAuLi5jb2wuZmlsdGVyQ29tcG9uZW50UHJvcHMsXG4gICAgICAuLi5zZWxlY3RUcmFuc2xhdGlvbnMsXG4gICAgfTtcblxuICAgIHJldHVybiBzZWxlY3RSZW5kZXIoeyAuLi5mc1Byb3BzIH0pO1xuICB9LFxuXG59O1xuIl19