var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

import React from 'react';
import { FloatingSelectPortal } from '@opuscapita/react-floating-select';

export var selectRender = function selectRender(selectProps) {
  return React.createElement(FloatingSelectPortal, selectProps);
};

export default {
  cellEdit: function cellEdit(col, column, rowIndex, tabIndex, gridId, selectOptions, selectTranslations, editValueParser, functions, getComponentDisabledState) {
    var cellName = 'edit';
    var opts = col.editSelectOptionsMod && selectOptions ? col.editSelectOptionsMod(selectOptions.slice(), rowIndex, col) : selectOptions;
    var fsProps = _extends({
      name: 'ocDatagridEditInput-' + gridId + '-' + column.columnKey + '-' + rowIndex,
      options: opts,
      value: functions.getItemValue(rowIndex, col),
      onChange: functions.onCellValueChange(rowIndex, col, editValueParser),
      onBlur: functions.onCellBlur(rowIndex, col),
      onFocus: functions.onCellFocus(cellName, col.componentType, rowIndex, column.columnKey),
      isSearchable: selectOptions && selectOptions.length > 9,
      isClearable: !col.isRequired,
      backSpaceRemovesValue: false,
      tabSelectsValue: false,
      openMenuOnFocus: true,
      innerRef: functions.handleCellRef(rowIndex, col),
      isDisabled: getComponentDisabledState(rowIndex, col, cellName),
      tabIndex: tabIndex
    }, col.editComponentProps, selectTranslations);
    return selectRender(_extends({}, fsProps));
  },
  cellCreate: function cellCreate(col, column, rowIndex, tabIndex, gridId, selectOptions, selectTranslations, editValueParser, functions, getComponentDisabledState) {
    var cellName = 'create';
    var opts = col.createSelectOptionsMod && selectOptions ? col.createSelectOptionsMod(selectOptions.slice(), rowIndex, col) : selectOptions;

    var fsProps = _extends({
      name: 'ocDatagridCreateInput-' + gridId + '-' + column.columnKey + '-' + rowIndex,
      options: opts,
      value: functions.getItemValue(rowIndex, col),
      onChange: functions.onCellValueChange(rowIndex, col, editValueParser),
      onBlur: functions.onCellBlur(rowIndex, col),
      onFocus: functions.onCellFocus(cellName, col.componentType, rowIndex, column.columnKey),
      isSearchable: selectOptions && selectOptions.length > 9,
      isClearable: !col.isRequired,
      backspaceRemovesValue: false,
      tabSelectsValue: false,
      openMenuOnFocus: true,
      innerRef: functions.handleCellRef(rowIndex, col),
      isDisabled: getComponentDisabledState(rowIndex, col, cellName),
      tabIndex: tabIndex
    }, col.createComponentProps, selectTranslations);
    return selectRender(_extends({}, fsProps));
  },
  cellFilter: function cellFilter(col, column, tabIndex, gridId, selectOptions, selectTranslations, editValueParser, functions) {
    var opts = col.filterSelectOptionsMod && selectOptions ? col.filterSelectOptionsMod(selectOptions.slice(), col) : selectOptions;
    var fsProps = _extends({
      name: 'ocDatagridFilterInput-' + gridId + '-' + column.columnKey,
      options: opts,
      value: functions.getItemValue(col),
      onChange: functions.onCellValueChange(col, editValueParser),
      isSearchable: selectOptions && selectOptions.length > 9,
      isClearable: true,
      tabSelectsValue: false,
      openMenuOnFocus: true,
      tabIndex: tabIndex
    }, col.filterComponentProps, selectTranslations);

    return selectRender(_extends({}, fsProps));
  }
};
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3NyYy9kYXRhZ3JpZC9jb2x1bW4tc2VydmljZS9jb2x1bW4tdHlwZXMvc2VsZWN0LXJlbmRlcmVycy5qc3giXSwibmFtZXMiOlsiUmVhY3QiLCJGbG9hdGluZ1NlbGVjdFBvcnRhbCIsInNlbGVjdFJlbmRlciIsInNlbGVjdFByb3BzIiwiY2VsbEVkaXQiLCJjb2wiLCJjb2x1bW4iLCJyb3dJbmRleCIsInRhYkluZGV4IiwiZ3JpZElkIiwic2VsZWN0T3B0aW9ucyIsInNlbGVjdFRyYW5zbGF0aW9ucyIsImVkaXRWYWx1ZVBhcnNlciIsImZ1bmN0aW9ucyIsImdldENvbXBvbmVudERpc2FibGVkU3RhdGUiLCJjZWxsTmFtZSIsIm9wdHMiLCJlZGl0U2VsZWN0T3B0aW9uc01vZCIsInNsaWNlIiwiZnNQcm9wcyIsIm5hbWUiLCJjb2x1bW5LZXkiLCJvcHRpb25zIiwidmFsdWUiLCJnZXRJdGVtVmFsdWUiLCJvbkNoYW5nZSIsIm9uQ2VsbFZhbHVlQ2hhbmdlIiwib25CbHVyIiwib25DZWxsQmx1ciIsIm9uRm9jdXMiLCJvbkNlbGxGb2N1cyIsImNvbXBvbmVudFR5cGUiLCJpc1NlYXJjaGFibGUiLCJsZW5ndGgiLCJpc0NsZWFyYWJsZSIsImlzUmVxdWlyZWQiLCJiYWNrU3BhY2VSZW1vdmVzVmFsdWUiLCJ0YWJTZWxlY3RzVmFsdWUiLCJvcGVuTWVudU9uRm9jdXMiLCJpbm5lclJlZiIsImhhbmRsZUNlbGxSZWYiLCJpc0Rpc2FibGVkIiwiZWRpdENvbXBvbmVudFByb3BzIiwiY2VsbENyZWF0ZSIsImNyZWF0ZVNlbGVjdE9wdGlvbnNNb2QiLCJiYWNrc3BhY2VSZW1vdmVzVmFsdWUiLCJjcmVhdGVDb21wb25lbnRQcm9wcyIsImNlbGxGaWx0ZXIiLCJmaWx0ZXJTZWxlY3RPcHRpb25zTW9kIiwiZmlsdGVyQ29tcG9uZW50UHJvcHMiXSwibWFwcGluZ3MiOiI7O0FBQUEsT0FBT0EsS0FBUCxNQUFrQixPQUFsQjtBQUNBLFNBQVND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QUF6R1ksQ0FBZiIsImZpbGUiOiJzZWxlY3QtcmVuZGVyZXJzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IEZsb2F0aW5nU2VsZWN0UG9ydGFsIH0gZnJvbSAnQG9wdXNjYXBpdGEvcmVhY3QtZmxvYXRpbmctc2VsZWN0JztcblxuZXhwb3J0IGNvbnN0IHNlbGVjdFJlbmRlciA9IHNlbGVjdFByb3BzID0+IChcbiAgPEZsb2F0aW5nU2VsZWN0UG9ydGFsIHsuLi5zZWxlY3RQcm9wc30gLz5cbik7XG5cblxuZXhwb3J0IGRlZmF1bHQge1xuXG4gIGNlbGxFZGl0KFxuICAgIGNvbCxcbiAgICBjb2x1bW4sXG4gICAgcm93SW5kZXgsXG4gICAgdGFiSW5kZXgsXG4gICAgZ3JpZElkLFxuICAgIHNlbGVjdE9wdGlvbnMsXG4gICAgc2VsZWN0VHJhbnNsYXRpb25zLFxuICAgIGVkaXRWYWx1ZVBhcnNlcixcbiAgICBmdW5jdGlvbnMsXG4gICAgZ2V0Q29tcG9uZW50RGlzYWJsZWRTdGF0ZSxcbiAgKSB7XG4gICAgY29uc3QgY2VsbE5hbWUgPSAnZWRpdCc7XG4gICAgY29uc3Qgb3B0cyA9IGNvbC5lZGl0U2VsZWN0T3B0aW9uc01vZCAmJiBzZWxlY3RPcHRpb25zID9cbiAgICAgIGNvbC5lZGl0U2VsZWN0T3B0aW9uc01vZChzZWxlY3RPcHRpb25zLnNsaWNlKCksIHJvd0luZGV4LCBjb2wpIDpcbiAgICAgIHNlbGVjdE9wdGlvbnM7XG4gICAgY29uc3QgZnNQcm9wcyA9IHtcbiAgICAgIG5hbWU6IGBvY0RhdGFncmlkRWRpdElucHV0LSR7Z3JpZElkfS0ke2NvbHVtbi5jb2x1bW5LZXl9LSR7cm93SW5kZXh9YCxcbiAgICAgIG9wdGlvbnM6IG9wdHMsXG4gICAgICB2YWx1ZTogZnVuY3Rpb25zLmdldEl0ZW1WYWx1ZShyb3dJbmRleCwgY29sKSxcbiAgICAgIG9uQ2hhbmdlOiBmdW5jdGlvbnMub25DZWxsVmFsdWVDaGFuZ2Uocm93SW5kZXgsIGNvbCwgZWRpdFZhbHVlUGFyc2VyKSxcbiAgICAgIG9uQmx1cjogZnVuY3Rpb25zLm9uQ2VsbEJsdXIocm93SW5kZXgsIGNvbCksXG4gICAgICBvbkZvY3VzOiBmdW5jdGlvbnMub25DZWxsRm9jdXMoY2VsbE5hbWUsIGNvbC5jb21wb25lbnRUeXBlLCByb3dJbmRleCwgY29sdW1uLmNvbHVtbktleSksXG4gICAgICBpc1NlYXJjaGFibGU6IHNlbGVjdE9wdGlvbnMgJiYgKHNlbGVjdE9wdGlvbnMubGVuZ3RoID4gOSksXG4gICAgICBpc0NsZWFyYWJsZTogIWNvbC5pc1JlcXVpcmVkLFxuICAgICAgYmFja1NwYWNlUmVtb3Zlc1ZhbHVlOiBmYWxzZSxcbiAgICAgIHRhYlNlbGVjdHNWYWx1ZTogZmFsc2UsXG4gICAgICBvcGVuTWVudU9uRm9jdXM6IHRydWUsXG4gICAgICBpbm5lclJlZjogZnVuY3Rpb25zLmhhbmRsZUNlbGxSZWYocm93SW5kZXgsIGNvbCksXG4gICAgICBpc0Rpc2FibGVkOiBnZXRDb21wb25lbnREaXNhYmxlZFN0YXRlKHJvd0luZGV4LCBjb2wsIGNlbGxOYW1lKSxcbiAgICAgIHRhYkluZGV4LFxuICAgICAgLi4uY29sLmVkaXRDb21wb25lbnRQcm9wcyxcbiAgICAgIC4uLnNlbGVjdFRyYW5zbGF0aW9ucyxcbiAgICB9O1xuICAgIHJldHVybiBzZWxlY3RSZW5kZXIoeyAuLi5mc1Byb3BzIH0pO1xuICB9LFxuXG4gIGNlbGxDcmVhdGUoXG4gICAgY29sLFxuICAgIGNvbHVtbixcbiAgICByb3dJbmRleCxcbiAgICB0YWJJbmRleCxcbiAgICBncmlkSWQsXG4gICAgc2VsZWN0T3B0aW9ucyxcbiAgICBzZWxlY3RUcmFuc2xhdGlvbnMsXG4gICAgZWRpdFZhbHVlUGFyc2VyLFxuICAgIGZ1bmN0aW9ucyxcbiAgICBnZXRDb21wb25lbnREaXNhYmxlZFN0YXRlLFxuICApIHtcbiAgICBjb25zdCBjZWxsTmFtZSA9ICdjcmVhdGUnO1xuICAgIGNvbnN0IG9wdHMgPSBjb2wuY3JlYXRlU2VsZWN0T3B0aW9uc01vZCAmJiBzZWxlY3RPcHRpb25zID9cbiAgICAgIGNvbC5jcmVhdGVTZWxlY3RPcHRpb25zTW9kKHNlbGVjdE9wdGlvbnMuc2xpY2UoKSwgcm93SW5kZXgsIGNvbCkgOlxuICAgICAgc2VsZWN0T3B0aW9ucztcblxuICAgIGNvbnN0IGZzUHJvcHMgPSB7XG4gICAgICBuYW1lOiBgb2NEYXRhZ3JpZENyZWF0ZUlucHV0LSR7Z3JpZElkfS0ke2NvbHVtbi5jb2x1bW5LZXl9LSR7cm93SW5kZXh9YCxcbiAgICAgIG9wdGlvbnM6IG9wdHMsXG4gICAgICB2YWx1ZTogZnVuY3Rpb25zLmdldEl0ZW1WYWx1ZShyb3dJbmRleCwgY29sKSxcbiAgICAgIG9uQ2hhbmdlOiBmdW5jdGlvbnMub25DZWxsVmFsdWVDaGFuZ2Uocm93SW5kZXgsIGNvbCwgZWRpdFZhbHVlUGFyc2VyKSxcbiAgICAgIG9uQmx1cjogZnVuY3Rpb25zLm9uQ2VsbEJsdXIocm93SW5kZXgsIGNvbCksXG4gICAgICBvbkZvY3VzOiBmdW5jdGlvbnMub25DZWxsRm9jdXMoY2VsbE5hbWUsIGNvbC5jb21wb25lbnRUeXBlLCByb3dJbmRleCwgY29sdW1uLmNvbHVtbktleSksXG4gICAgICBpc1NlYXJjaGFibGU6IHNlbGVjdE9wdGlvbnMgJiYgKHNlbGVjdE9wdGlvbnMubGVuZ3RoID4gOSksXG4gICAgICBpc0NsZWFyYWJsZTogIWNvbC5pc1JlcXVpcmVkLFxuICAgICAgYmFja3NwYWNlUmVtb3Zlc1ZhbHVlOiBmYWxzZSxcbiAgICAgIHRhYlNlbGVjdHNWYWx1ZTogZmFsc2UsXG4gICAgICBvcGVuTWVudU9uRm9jdXM6IHRydWUsXG4gICAgICBpbm5lclJlZjogZnVuY3Rpb25zLmhhbmRsZUNlbGxSZWYocm93SW5kZXgsIGNvbCksXG4gICAgICBpc0Rpc2FibGVkOiBnZXRDb21wb25lbnREaXNhYmxlZFN0YXRlKHJvd0luZGV4LCBjb2wsIGNlbGxOYW1lKSxcbiAgICAgIHRhYkluZGV4LFxuICAgICAgLi4uY29sLmNyZWF0ZUNvbXBvbmVudFByb3BzLFxuICAgICAgLi4uc2VsZWN0VHJhbnNsYXRpb25zLFxuICAgIH07XG4gICAgcmV0dXJuIHNlbGVjdFJlbmRlcih7IC4uLmZzUHJvcHMgfSk7XG4gIH0sXG5cbiAgY2VsbEZpbHRlcihcbiAgICBjb2wsXG4gICAgY29sdW1uLFxuICAgIHRhYkluZGV4LFxuICAgIGdyaWRJZCxcbiAgICBzZWxlY3RPcHRpb25zLFxuICAgIHNlbGVjdFRyYW5zbGF0aW9ucyxcbiAgICBlZGl0VmFsdWVQYXJzZXIsXG4gICAgZnVuY3Rpb25zLFxuICApIHtcbiAgICBjb25zdCBvcHRzID0gY29sLmZpbHRlclNlbGVjdE9wdGlvbnNNb2QgJiYgc2VsZWN0T3B0aW9ucyA/XG4gICAgICBjb2wuZmlsdGVyU2VsZWN0T3B0aW9uc01vZChzZWxlY3RPcHRpb25zLnNsaWNlKCksIGNvbCkgOlxuICAgICAgc2VsZWN0T3B0aW9ucztcbiAgICBjb25zdCBmc1Byb3BzID0ge1xuICAgICAgbmFtZTogYG9jRGF0YWdyaWRGaWx0ZXJJbnB1dC0ke2dyaWRJZH0tJHtjb2x1bW4uY29sdW1uS2V5fWAsXG4gICAgICBvcHRpb25zOiBvcHRzLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9ucy5nZXRJdGVtVmFsdWUoY29sKSxcbiAgICAgIG9uQ2hhbmdlOiBmdW5jdGlvbnMub25DZWxsVmFsdWVDaGFuZ2UoY29sLCBlZGl0VmFsdWVQYXJzZXIpLFxuICAgICAgaXNTZWFyY2hhYmxlOiBzZWxlY3RPcHRpb25zICYmIChzZWxlY3RPcHRpb25zLmxlbmd0aCA+IDkpLFxuICAgICAgaXNDbGVhcmFibGU6IHRydWUsXG4gICAgICB0YWJTZWxlY3RzVmFsdWU6IGZhbHNlLFxuICAgICAgb3Blbk1lbnVPbkZvY3VzOiB0cnVlLFxuICAgICAgdGFiSW5kZXgsXG4gICAgICAuLi5jb2wuZmlsdGVyQ29tcG9uZW50UHJvcHMsXG4gICAgICAuLi5zZWxlY3RUcmFuc2xhdGlvbnMsXG4gICAgfTtcblxuICAgIHJldHVybiBzZWxlY3RSZW5kZXIoeyAuLi5mc1Byb3BzIH0pO1xuICB9LFxuXG59O1xuIl19