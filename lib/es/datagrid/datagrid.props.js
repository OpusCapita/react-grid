/* eslint-disable react/no-unused-prop-types, react/forbid-prop-types, max-len */
/* eslint-disable no-multi-spaces, object-curly-newline */
import PropTypes from 'prop-types';
import ImmutablePropTypes from 'react-immutable-proptypes';

var bool = PropTypes.bool,
    number = PropTypes.number,
    string = PropTypes.string,
    func = PropTypes.func,
    object = PropTypes.object,
    node = PropTypes.node,
    array = PropTypes.array,
    shape = PropTypes.shape,
    any = PropTypes.any,
    oneOfType = PropTypes.oneOfType,
    arrayOf = PropTypes.arrayOf;
var list = ImmutablePropTypes.list,
    map = ImmutablePropTypes.map,
    mapOf = ImmutablePropTypes.mapOf;


export var configStorageShape = shape({
  load: func.isRequired,
  save: func.isRequired
});

// Grid object holds data that also actions uses
export var gridShape = shape({
  id: string.isRequired,
  idKeyPath: arrayOf(string).isRequired, // keyPath to id data
  defaultShowFilteringRow: bool, // is filtering row shown as default
  defaultSortColumn: string, // columnKey of column that is sorted by default
  defaultSortOrder: string, // default sort order [asc/desc]
  disableRememberColumnWidths: bool,
  disableRememberSortData: bool,
  disableRememberIsFiltering: bool,
  disableRememberFilteData: bool,
  disableRememberSelectedItems: bool,
  language: string,
  dateFormat: string,
  thousandSeparator: string,
  decimalSeparator: string,
  configStorage: configStorageShape
});

export var columnShape = shape({
  header: node,
  columnKey: string, // Use valueKeyPath if possible, this is calculated from there
  valueKeyPath: array, // key path for the cell data value, required if no columnKey is given
  valueType: string, // data value type [text/number/float/boolean/date]
  valueOptions: shape({ // options for the value type
    currencyKeyPath: array, // key path to currency code (only for currency data type)
    decimals: number, // number of decimals override
    thousandSeparator: string, // thousand separator override
    decimalSeparator: string // decimal separator override
  }),
  componentType: string, // edit component type [text/number/float/select/boolean/date]
  valueRender: func, // custom renderer for the value, data as parameter
  editValueRender: func, // custom renderer for the edit value, data as parameter
  createValueRender: func, // custom renderer for the create value, data as parameter
  filterValueRender: func, // custom renderer for the filter value, data as parameter
  cell: func, // override cell renderer, rowIndex as parameter
  cellEdit: func, // override cellEdit renderer, rowIndex as parameter
  cellCreate: func, // override cellCreate renderer, rowIndex as parameter
  cellFilter: func, // override cellFilter renderer, rowIndex as parameter
  renderComponentProps: object, // additional props to the render component
  editComponentProps: object, // additional props to the edit component
  createComponentProps: object, // additional props to the create component
  filterComponentProps: object, // additional props to the filter component
  width: number,
  minWidth: number,
  maxWidth: number,
  align: string, // vertical cell alignment, defaults to 'left'
  fixed: bool, // is column fixed
  allowCellsRecycling: bool, // allow cells to be recycled for better horizontal scrolling perf
  disableResizing: bool, // disable column resizing
  disableEditing: bool, // disable input component (make read-only) when editing/creating
  disableSorting: bool, // disable filtering on this column
  disableEditingOnValueMatch: shape({ // disable editing/creating input when other columns value match
    matchValueKeyPath: array,
    matchValue: any
  }),
  onValueMatchChangeValue: shape({ // Change other column value when data matches
    matchValue: any,
    newValueKeyPath: array,
    newValue: any
  }),
  flexGrow: number,
  valueEmptyChecker: func, // override function that checks if value is considered as empty
  sortValueGetter: func, // override sort value getter, defaults to getIn(valueKeyPath)
  sortComparator: func, // override sort comparator function, default sorts by valueType
  filterMatcher: func, // override filter matcher function, that defined when filter matches data
  defaultValue: any, // default value for the column when creating new item
  isRequired: bool, // is column value required
  isHidden: bool, // is column hidden by default
  onEditValueChange: func, // callback with (value, valueKeyPath, rowIndex, dataId)
  onCreateValueChange: func, // callbac with (value, valueKeyPath, rowIndex)
  onCreateBlur: func, // callback with (value, rowIndex)
  onEditBlur: func, // callback with (value, rowIndex, dataId)
  selectComponentOptions: arrayOf(shape({
    value: oneOfType([number, string, bool]).isRequired,
    label: oneOfType([number, string]).isRequired
  })),
  selectComponentTranslations: shape({ // customize select components placeholder and noResults texts.
    placeholder: string,
    noResultsText: string
  })
});

export var propTypes = {
  children: node,
  // App props
  intl: object.isRequired,
  // Action props
  addNewItem: func.isRequired,
  removeNewItem: func.isRequired,
  create: func.isRequired,
  edit: func.isRequired,
  remove: func.isRequired,
  save: func.isRequired,
  cancel: func.isRequired,
  sortChange: func.isRequired,
  resizeColumn: func.isRequired,
  invalidate: func.isRequired,
  cellSelectionChange: func.isRequired,
  itemSelectionChange: func.isRequired,
  toggleFiltering: func.isRequired,
  editCellValueChange: func.isRequired,
  createCellValueChange: func.isRequired,
  filterCellValueChange: func.isRequired,
  editCellValueValidate: func.isRequired,
  createCellValueValidate: func.isRequired,
  validateEditedRows: func.isRequired,
  validateCreatedRows: func.isRequired,
  // State props
  isBusy: bool.isRequired,
  isEditing: bool.isRequired,
  isCreating: bool.isRequired,
  isFiltering: bool.isRequired,
  sortColumn: oneOfType([string, number]),
  sortOrder: string,
  visibleColumns: list.isRequired,
  columnWidths: map.isRequired,
  selectedCell: map.isRequired,
  selectedItems: list.isRequired,
  data: list.isRequired,
  editData: map.isRequired,
  createData: list.isRequired,
  filterData: map.isRequired,
  cellMessages: map.isRequired,
  createCellMessages: map.isRequired,
  language: string.isRequired,
  thousandSeparator: string.isRequired,
  decimalSeparator: string.isRequired,
  allDataSize: number.isRequired,
  // Required component properties
  grid: gridShape.isRequired,
  columns: arrayOf(columnShape.isRequired).isRequired,
  // Optional component properties
  rowsCount: number,
  gridHeader: node,
  actionBar: node,
  actionBarLeft: node,
  cellSelect: bool,
  disableDropdown: bool, // Don't use dropdown menu in the action bar
  disableFilteringControls: bool, // Don't display the filtering controls (only valid if disableDropdown is true)
  dropdownMenuItems: array,
  inlineEdit: bool,
  inlineAdd: bool,
  filtering: bool,
  removing: bool,
  columnSettings: bool,
  rowSelect: bool,
  rowSelectCheckboxColumn: bool,
  multiSelect: bool,
  selectComponentOptions: mapOf(arrayOf(shape({ // Options data for the react-select components
    value: oneOfType([number, string, bool]).isRequired,
    label: oneOfType([number, string]).isRequired
  }))),
  selectComponentTranslations: shape({ // Options for react-select text translations
    placeholder: string.isRequired,
    noResultsText: string.isRequired
  }),
  disableActions: bool, // Disable actions in the action bar
  disableActionsMessage: shape({
    messageId: string,
    messageValues: shape({})
  }),
  disableActionBar: bool,
  disableActionSave: bool,
  enableArrowNavigation: bool,
  onSave: func,
  onRemove: func,
  onCancel: func,
  onAddClick: func,
  onEditClick: func,
  tabIndex: number, // tabIndex value for inputs in cells
  extraColumn: shape({ // Extra fixed column that can't be re-ordered or hidden
    width: string,
    valueRender: func,
    cellEdit: func,
    cellCreate: func,
    cellFilter: func,
    isResizable: bool
  }),
  contextMenuItems: arrayOf(shape({ // Context menu items to display when row is right-clicked
    value: node,
    onClick: func,
    title: string,
    header: bool,
    disabled: oneOfType([bool, func]),
    divider: bool
  })),
  // Fixed data table built-in features
  headerHeight: number,
  filterRowHeight: number,
  rowHeight: number,
  containerStyle: object,
  scrollToColumn: number,
  scrollTop: number,
  scrollToRow: number,
  onRowClick: func,
  onRowDoubleClick: func,
  onRowMouseDown: func,
  onRowMouseEnter: func,
  onRowMouseLeave: func,
  onScrollStart: func,
  onScrollEnd: func,
  rowClassNameGetter: func,
  rowHeightGetter: func,
  onContentHeightChange: func
};

/* eslint-enable max-len, prefer-template, react/no-unused-prop-types, react/forbid-prop-types */

export var defaultProps = {
  cellSelect: false,
  columnSettings: false,
  children: undefined,
  containerStyle: {},
  disableActionSave: false,
  enableArrowNavigation: false,
  headerHeight: 40,
  filterRowHeight: 40,
  rowHeight: 40,
  onSave: function onSave() {},
  onRemove: function onRemove() {},
  onCancel: function onCancel() {},
  tabIndex: 1,
  disableFilteringControls: false
};
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9kYXRhZ3JpZC9kYXRhZ3JpZC5wcm9wcy5qcyJdLCJuYW1lcyI6WyJQcm9wVHlwZXMiLCJJbW11dGFibGVQcm9wVHlwZXMiLCJib29sIiwibnVtYmVyIiwic3RyaW5nIiwiZnVuYyIsIm9iamVjdCIsIm5vZGUiLCJhcnJheSIsInNoYXBlIiwiYW55Iiwib25lT2ZUeXBlIiwiYXJyYXlPZiIsImxpc3QiLCJtYXAiLCJtYXBPZiIsImNvbmZpZ1N0b3JhZ2VTaGFwZSIsImxvYWQiLCJpc1JlcXVpcmVkIiwic2F2ZSIsImdyaWRTaGFwZSIsImlkIiwiaWRLZXlQYXRoIiwiZGVmYXVsdFNob3dGaWx0ZXJpbmdSb3ciLCJkZWZhdWx0U29ydENvbHVtbiIsImRlZmF1bHRTb3J0T3JkZXIiLCJkaXNhYmxlUmVtZW1iZXJDb2x1bW5XaWR0aHMiLCJkaXNhYmxlUmVtZW1iZXJTb3J0RGF0YSIsImRpc2FibGVSZW1lbWJlcklzRmlsdGVyaW5nIiwiZGlzYWJsZVJlbWVtYmVyRmlsdGVEYXRhIiwiZGlzYWJsZVJlbWVtYmVyU2VsZWN0ZWRJdGVtcyIsImxhbmd1YWdlIiwiZGF0ZUZvcm1hdCIsInRob3VzYW5kU2VwYXJhdG9yIiwiZGVjaW1hbFNlcGFyYXRvciIsImNvbmZpZ1N0b3JhZ2UiLCJjb2x1bW5TaGFwZSIsImhlYWRlciIsImNvbHVtbktleSIsInZhbHVlS2V5UGF0aCIsInZhbHVlVHlwZSIsInZhbHVlT3B0aW9ucyIsImN1cnJlbmN5S2V5UGF0aCIsImRlY2ltYWxzIiwiY29tcG9uZW50VHlwZSIsInZhbHVlUmVuZGVyIiwiZWRpdFZhbHVlUmVuZGVyIiwiY3JlYXRlVmFsdWVSZW5kZXIiLCJmaWx0ZXJWYWx1ZVJlbmRlciIsImNlbGwiLCJjZWxsRWRpdCIsImNlbGxDcmVhdGUiLCJjZWxsRmlsdGVyIiwicmVuZGVyQ29tcG9uZW50UHJvcHMiLCJlZGl0Q29tcG9uZW50UHJvcHMiLCJjcmVhdGVDb21wb25lbnRQcm9wcyIsImZpbHRlckNvbXBvbmVudFByb3BzIiwid2lkdGgiLCJtaW5XaWR0aCIsIm1heFdpZHRoIiwiYWxpZ24iLCJmaXhlZCIsImFsbG93Q2VsbHNSZWN5Y2xpbmciLCJkaXNhYmxlUmVzaXppbmciLCJkaXNhYmxlRWRpdGluZyIsImRpc2FibGVTb3J0aW5nIiwiZGlzYWJsZUVkaXRpbmdPblZhbHVlTWF0Y2giLCJtYXRjaFZhbHVlS2V5UGF0aCIsIm1hdGNoVmFsdWUiLCJvblZhbHVlTWF0Y2hDaGFuZ2VWYWx1ZSIsIm5ld1ZhbHVlS2V5UGF0aCIsIm5ld1ZhbHVlIiwiZmxleEdyb3ciLCJ2YWx1ZUVtcHR5Q2hlY2tlciIsInNvcnRWYWx1ZUdldHRlciIsInNvcnRDb21wYXJhdG9yIiwiZmlsdGVyTWF0Y2hlciIsImRlZmF1bHRWYWx1ZSIsImlzSGlkZGVuIiwib25FZGl0VmFsdWVDaGFuZ2UiLCJvbkNyZWF0ZVZhbHVlQ2hhbmdlIiwib25DcmVhdGVCbHVyIiwib25FZGl0Qmx1ciIsInNlbGVjdENvbXBvbmVudE9wdGlvbnMiLCJ2YWx1ZSIsImxhYmVsIiwic2VsZWN0Q29tcG9uZW50VHJhbnNsYXRpb25zIiwicGxhY2Vob2xkZXIiLCJub1Jlc3VsdHNUZXh0IiwicHJvcFR5cGVzIiwiY2hpbGRyZW4iLCJpbnRsIiwiYWRkTmV3SXRlbSIsInJlbW92ZU5ld0l0ZW0iLCJjcmVhdGUiLCJlZGl0IiwicmVtb3ZlIiwiY2FuY2VsIiwic29ydENoYW5nZSIsInJlc2l6ZUNvbHVtbiIsImludmFsaWRhdGUiLCJjZWxsU2VsZWN0aW9uQ2hhbmdlIiwiaXRlbVNlbGVjdGlvbkNoYW5nZSIsInRvZ2dsZUZpbHRlcmluZyIsImVkaXRDZWxsVmFsdWVDaGFuZ2UiLCJjcmVhdGVDZWxsVmFsdWVDaGFuZ2UiLCJmaWx0ZXJDZWxsVmFsdWVDaGFuZ2UiLCJlZGl0Q2VsbFZhbHVlVmFsaWRhdGUiLCJjcmVhdGVDZWxsVmFsdWVWYWxpZGF0ZSIsInZhbGlkYXRlRWRpdGVkUm93cyIsInZhbGlkYXRlQ3JlYXRlZFJvd3MiLCJpc0J1c3kiLCJpc0VkaXRpbmciLCJpc0NyZWF0aW5nIiwiaXNGaWx0ZXJpbmciLCJzb3J0Q29sdW1uIiwic29ydE9yZGVyIiwidmlzaWJsZUNvbHVtbnMiLCJjb2x1bW5XaWR0aHMiLCJzZWxlY3RlZENlbGwiLCJzZWxlY3RlZEl0ZW1zIiwiZGF0YSIsImVkaXREYXRhIiwiY3JlYXRlRGF0YSIsImZpbHRlckRhdGEiLCJjZWxsTWVzc2FnZXMiLCJjcmVhdGVDZWxsTWVzc2FnZXMiLCJhbGxEYXRhU2l6ZSIsImdyaWQiLCJjb2x1bW5zIiwicm93c0NvdW50IiwiZ3JpZEhlYWRlciIsImFjdGlvbkJhciIsImFjdGlvbkJhckxlZnQiLCJjZWxsU2VsZWN0IiwiZGlzYWJsZURyb3Bkb3duIiwiZGlzYWJsZUZpbHRlcmluZ0NvbnRyb2xzIiwiZHJvcGRvd25NZW51SXRlbXMiLCJpbmxpbmVFZGl0IiwiaW5saW5lQWRkIiwiZmlsdGVyaW5nIiwicmVtb3ZpbmciLCJjb2x1bW5TZXR0aW5ncyIsInJvd1NlbGVjdCIsInJvd1NlbGVjdENoZWNrYm94Q29sdW1uIiwibXVsdGlTZWxlY3QiLCJkaXNhYmxlQWN0aW9ucyIsImRpc2FibGVBY3Rpb25zTWVzc2FnZSIsIm1lc3NhZ2VJZCIsIm1lc3NhZ2VWYWx1ZXMiLCJkaXNhYmxlQWN0aW9uQmFyIiwiZGlzYWJsZUFjdGlvblNhdmUiLCJlbmFibGVBcnJvd05hdmlnYXRpb24iLCJvblNhdmUiLCJvblJlbW92ZSIsIm9uQ2FuY2VsIiwib25BZGRDbGljayIsIm9uRWRpdENsaWNrIiwidGFiSW5kZXgiLCJleHRyYUNvbHVtbiIsImlzUmVzaXphYmxlIiwiY29udGV4dE1lbnVJdGVtcyIsIm9uQ2xpY2siLCJ0aXRsZSIsImRpc2FibGVkIiwiZGl2aWRlciIsImhlYWRlckhlaWdodCIsImZpbHRlclJvd0hlaWdodCIsInJvd0hlaWdodCIsImNvbnRhaW5lclN0eWxlIiwic2Nyb2xsVG9Db2x1bW4iLCJzY3JvbGxUb3AiLCJzY3JvbGxUb1JvdyIsIm9uUm93Q2xpY2siLCJvblJvd0RvdWJsZUNsaWNrIiwib25Sb3dNb3VzZURvd24iLCJvblJvd01vdXNlRW50ZXIiLCJvblJvd01vdXNlTGVhdmUiLCJvblNjcm9sbFN0YXJ0Iiwib25TY3JvbGxFbmQiLCJyb3dDbGFzc05hbWVHZXR0ZXIiLCJyb3dIZWlnaHRHZXR0ZXIiLCJvbkNvbnRlbnRIZWlnaHRDaGFuZ2UiLCJkZWZhdWx0UHJvcHMiLCJ1bmRlZmluZWQiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQSxPQUFPQSxTQUFQLE1BQXNCLFlBQXRCO0FBQ0EsT0FBT0Msa0JBQVAsTUFBK0IsMkJBQS9COztJQUVRQyxJLEdBQW9GRixTLENBQXBGRSxJO0lBQU1DLE0sR0FBOEVILFMsQ0FBOUVHLE07SUFBUUMsTSxHQUFzRUosUyxDQUF0RUksTTtJQUFRQyxJLEdBQThETCxTLENBQTlESyxJO0lBQU1DLE0sR0FBd0ROLFMsQ0FBeERNLE07SUFBUUMsSSxHQUFnRFAsUyxDQUFoRE8sSTtJQUFNQyxLLEdBQTBDUixTLENBQTFDUSxLO0lBQU9DLEssR0FBbUNULFMsQ0FBbkNTLEs7SUFBT0MsRyxHQUE0QlYsUyxDQUE1QlUsRztJQUFLQyxTLEdBQXVCWCxTLENBQXZCVyxTO0lBQVdDLE8sR0FBWVosUyxDQUFaWSxPO0lBQ3hFQyxJLEdBQXFCWixrQixDQUFyQlksSTtJQUFNQyxHLEdBQWViLGtCLENBQWZhLEc7SUFBS0MsSyxHQUFVZCxrQixDQUFWYyxLOzs7QUFFbkIsT0FBTyxJQUFNQyxxQkFBcUJQLE1BQU07QUFDdENRLFFBQU1aLEtBQUthLFVBRDJCO0FBRXRDQyxRQUFNZCxLQUFLYTtBQUYyQixDQUFOLENBQTNCOztBQUtQO0FBQ0EsT0FBTyxJQUFNRSxZQUFZWCxNQUFNO0FBQzdCWSxNQUFJakIsT0FBT2MsVUFEa0I7QUFFN0JJLGFBQVdWLFFBQVFSLE1BQVIsRUFBZ0JjLFVBRkUsRUFFVTtBQUN2Q0ssMkJBQXlCckIsSUFISSxFQUdVO0FBQ3ZDc0IscUJBQW1CcEIsTUFKVSxFQUlVO0FBQ3ZDcUIsb0JBQWtCckIsTUFMVyxFQUtVO0FB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SyxjQUFVekosVUFBVSxDQUFDVCxJQUFELEVBQU9HLElBQVAsQ0FBVixDQUxvQjtBQU05QmdLLGFBQVNuSztBQU5xQixHQUFOLENBQVIsQ0FuR0s7QUEyR3ZCO0FBQ0FvSyxnQkFBY25LLE1BNUdTO0FBNkd2Qm9LLG1CQUFpQnBLLE1BN0dNO0FBOEd2QnFLLGFBQVdySyxNQTlHWTtBQStHdkJzSyxrQkFBZ0JuSyxNQS9HTztBQWdIdkJvSyxrQkFBZ0J2SyxNQWhITztBQWlIdkJ3SyxhQUFXeEssTUFqSFk7QUFrSHZCeUssZUFBYXpLLE1BbEhVO0FBbUh2QjBLLGNBQVl4SyxJQW5IVztBQW9IdkJ5SyxvQkFBa0J6SyxJQXBISztBQXFIdkIwSyxrQkFBZ0IxSyxJQXJITztBQXNIdkIySyxtQkFBaUIzSyxJQXRITTtBQXVIdkI0SyxtQkFBaUI1SyxJQXZITTtBQXdIdkI2SyxpQkFBZTdLLElBeEhRO0FBeUh2QjhLLGVBQWE5SyxJQXpIVTtBQTBIdkIrSyxzQkFBb0IvSyxJQTFIRztBQTJIdkJnTCxtQkFBaUJoTCxJQTNITTtBQTRIdkJpTCx5QkFBdUJqTDtBQTVIQSxDQUFsQjs7QUErSFA7O0FBRUEsT0FBTyxJQUFNa0wsZUFBZTtBQUMxQmpELGNBQVksS0FEYztBQUUxQlEsa0JBQWdCLEtBRlU7QUFHMUJwRCxZQUFVOEYsU0FIZ0I7QUFJMUJmLGtCQUFnQixFQUpVO0FBSzFCbEIscUJBQW1CLEtBTE87QUFNMUJDLHlCQUF1QixLQU5HO0FBTzFCYyxnQkFBYyxFQVBZO0FBUTFCQyxtQkFBaUIsRUFSUztBQVMxQkMsYUFBVyxFQVRlO0FBVTFCZixVQUFRLGtCQUFNLENBQUUsQ0FWVTtBQVcxQkMsWUFBVSxvQkFBTSxDQUFFLENBWFE7QUFZMUJDLFlBQVUsb0JBQU0sQ0FBRSxDQVpRO0FBYTFCRyxZQUFVLENBYmdCO0FBYzFCdEIsNEJBQTBCO0FBZEEsQ0FBckIiLCJmaWxlIjoiZGF0YWdyaWQucHJvcHMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQtZGlzYWJsZSByZWFjdC9uby11bnVzZWQtcHJvcC10eXBlcywgcmVhY3QvZm9yYmlkLXByb3AtdHlwZXMsIG1heC1sZW4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG5vLW11bHRpLXNwYWNlcywgb2JqZWN0LWN1cmx5LW5ld2xpbmUgKi9cbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgSW1tdXRhYmxlUHJvcFR5cGVzIGZyb20gJ3JlYWN0LWltbXV0YWJsZS1wcm9wdHlwZXMnO1xuXG5jb25zdCB7IGJvb2wsIG51bWJlciwgc3RyaW5nLCBmdW5jLCBvYmplY3QsIG5vZGUsIGFycmF5LCBzaGFwZSwgYW55LCBvbmVPZlR5cGUsIGFycmF5T2YgfSA9IFByb3BUeXBlcztcbmNvbnN0IHsgbGlzdCwgbWFwLCBtYXBPZiB9ID0gSW1tdXRhYmxlUHJvcFR5cGVzO1xuXG5leHBvcnQgY29uc3QgY29uZmlnU3RvcmFnZVNoYXBlID0gc2hhcGUoe1xuICBsb2FkOiBmdW5jLmlzUmVxdWlyZWQsXG4gIHNhdmU6IGZ1bmMuaXNSZXF1aXJlZCxcbn0pO1xuXG4vLyBHcmlkIG9iamVjdCBob2xkcyBkYXRhIHRoYXQgYWxzbyBhY3Rpb25zIHVzZXNcbmV4cG9ydCBjb25zdCBncmlkU2hhcGUgPSBzaGFwZSh7XG4gIGlkOiBzdHJpbmcuaXNSZXF1aXJlZCxcbiAgaWRLZXlQYXRoOiBhcnJheU9mKHN0cmluZykuaXNSZXF1aXJlZCwgLy8ga2V5UGF0aCB0byBpZCBkYXRhXG4gIGRlZmF1bHRTaG93RmlsdGVyaW5nUm93OiBib29sLCAgICAgICAgIC8vIGlzIGZpbHRlcmluZyByb3cgc2hvd24gYXMgZGVmYXVsdFxuICBkZWZhdWx0U29ydENvbHVtbjogc3RyaW5nLCAgICAgICAgICAgICAvLyBjb2x1bW5LZXkgb2YgY29sdW1uIHRoYXQgaXMgc29ydGVkIGJ5IGRlZmF1bHRcbiAgZGVmYXVsdFNvcnRPcmRlcjogc3RyaW5nLCAgICAgICAgICAgICAgLy8gZGVmYXVsdCBzb3J0IG9yZGVyIFthc2MvZGVzY11cbiAgZGlzYWJsZVJlbWVtYmVyQ29sdW1uV2lkdGhzOiBib29sLFxuICBkaXNhYmxlUmVtZW1iZXJTb3J0RGF0YTogYm9vbCxcbiAgZGlzYWJsZVJlbWVtYmVySXNGaWx0ZXJpbmc6IGJvb2wsXG4gIGRpc2FibGVSZW1lbWJlckZpbHRlRGF0YTogYm9vbCxcbiAgZGlzYWJsZVJlbWVtYmVyU2VsZWN0ZWRJdGVtczogYm9vbCxcbiAgbGFuZ3VhZ2U6IHN0cmluZyxcbiAgZGF0ZUZvcm1hdDogc3RyaW5nLFxuICB0aG91c2FuZFNlcGFyYXRvcjogc3RyaW5nLFxuICBkZWNpbWFsU2VwYXJhdG9yOiBzdHJpbmcsXG4gIGNvbmZpZ1N0b3JhZ2U6IGNvbmZpZ1N0b3JhZ2VTaGFwZSxcbn0pO1xuXG5leHBvcnQgY29uc3QgY29sdW1uU2hhcGUgPSBzaGFwZSh7XG4gIGhlYWRlcjogbm9kZSxcbiAgY29sdW1uS2V5OiBzdHJpbmcsICAgICAgICAgICAgICAvLyBVc2UgdmFsdWVLZXlQYXRoIGlmIHBvc3NpYmxlLCB0aGlzIGlzIGNhbGN1bGF0ZWQgZnJvbSB0aGVyZVxuICB2YWx1ZUtleVBhdGg6IGFycmF5LCAgICAgICAgICAgIC8vIGtleSBwYXRoIGZvciB0aGUgY2VsbCBkYXRhIHZhbHVlLCByZXF1aXJlZCBpZiBubyBjb2x1bW5LZXkgaXMgZ2l2ZW5cbiAgdmFsdWVUeXBlOiBzdHJpbmcsICAgICAgICAgICAgICAvLyBkYXRhIHZhbHVlIHR5cGUgW3RleHQvbnVtYmVyL2Zsb2F0L2Jvb2xlYW4vZGF0ZV1cbiAgdmFsdWVPcHRpb25zOiBzaGFwZSh7ICAgICAgICAgICAvLyBvcHRpb25zIGZvciB0aGUgdmFsdWUgdHlwZVxuICAgIGN1cnJlbmN5S2V5UGF0aDogYXJyYXksICAgICAgIC8vIGtleSBwYXRoIHRvIGN1cnJlbmN5IGNvZGUgKG9ubHkgZm9yIGN1cnJlbmN5IGRhdGEgdHlwZSlcbiAgICBkZWNpbWFsczogbnVtYmVyLCAgICAgICAgICAgICAvLyBudW1iZXIgb2YgZGVjaW1hbHMgb3ZlcnJpZGVcbiAgICB0aG91c2FuZFNlcGFyYXRvcjogc3RyaW5nLCAgICAvLyB0aG91c2FuZCBzZXBhcmF0b3Igb3ZlcnJpZGVcbiAgICBkZWNpbWFsU2VwYXJhdG9yOiBzdHJpbmcsICAgICAvLyBkZWNpbWFsIHNlcGFyYXRvciBvdmVycmlkZVxuICB9KSxcbiAgY29tcG9uZW50VHlwZTogc3RyaW5nLCAgICAgICAgICAvLyBlZGl0IGNvbXBvbmVudCB0eXBlIFt0ZXh0L251bWJlci9mbG9hdC9zZWxlY3QvYm9vbGVhbi9kYXRlXVxuICB2YWx1ZVJlbmRlcjogZnVuYywgICAgICAgICAgICAgIC8vIGN1c3RvbSByZW5kZXJlciBmb3IgdGhlIHZhbHVlLCBkYXRhIGFzIHBhcmFtZXRlclxuICBlZGl0VmFsdWVSZW5kZXI6IGZ1bmMsICAgICAgICAgIC8vIGN1c3RvbSByZW5kZXJlciBmb3IgdGhlIGVkaXQgdmFsdWUsIGRhdGEgYXMgcGFyYW1ldGVyXG4gIGNyZWF0ZVZhbHVlUmVuZGVyOiBmdW5jLCAgICAgICAgLy8gY3VzdG9tIHJlbmRlcmVyIGZvciB0aGUgY3JlYXRlIHZhbHVlLCBkYXRhIGFzIHBhcmFtZXRlclxuICBmaWx0ZXJWYWx1ZVJlbmRlcjogZnVuYywgICAgICAgIC8vIGN1c3RvbSByZW5kZXJlciBmb3IgdGhlIGZpbHRlciB2YWx1ZSwgZGF0YSBhcyBwYXJhbWV0ZXJcbiAgY2VsbDogZnVuYywgICAgICAgICAgICAgICAgICAgICAvLyBvdmVycmlkZSBjZWxsIHJlbmRlcmVyLCByb3dJbmRleCBhcyBwYXJhbWV0ZXJcbiAgY2VsbEVkaXQ6IGZ1bmMsICAgICAgICAgICAgICAgICAvLyBvdmVycmlkZSBjZWxsRWRpdCByZW5kZXJlciwgcm93SW5kZXggYXMgcGFyYW1ldGVyXG4gIGNlbGxDcmVhdGU6IGZ1bmMsICAgICAgICAgICAgICAgLy8gb3ZlcnJpZGUgY2VsbENyZWF0ZSByZW5kZXJlciwgcm93SW5kZXggYXMgcGFyYW1ldGVyXG4gIGNlbGxGaWx0ZXI6IGZ1bmMsICAgICAgICAgICAgICAgLy8gb3ZlcnJpZGUgY2VsbEZpbHRlciByZW5kZXJlciwgcm93SW5kZXggYXMgcGFyYW1ldGVyXG4gIHJlbmRlckNvbXBvbmVudFByb3BzOiBvYmplY3QsICAgLy8gYWRkaXRpb25hbCBwcm9wcyB0byB0aGUgcmVuZGVyIGNvbXBvbmVudFxuICBlZGl0Q29tcG9uZW50UHJvcHM6IG9iamVjdCwgICAgIC8vIGFkZGl0aW9uYWwgcHJvcHMgdG8gdGhlIGVkaXQgY29tcG9uZW50XG4gIGNyZWF0ZUNvbXBvbmVudFByb3BzOiBvYmplY3QsICAgLy8gYWRkaXRpb25hbCBwcm9wcyB0byB0aGUgY3JlYXRlIGNvbXBvbmVudFxuICBmaWx0ZXJDb21wb25lbnRQcm9wczogb2JqZWN0LCAgIC8vIGFkZGl0aW9uYWwgcHJvcHMgdG8gdGhlIGZpbHRlciBjb21wb25lbnRcbiAgd2lkdGg6IG51bWJlcixcbiAgbWluV2lkdGg6IG51bWJlcixcbiAgbWF4V2lkdGg6IG51bWJlcixcbiAgYWxpZ246IHN0cmluZywgICAgICAgICAgICAgICAgICAvLyB2ZXJ0aWNhbCBjZWxsIGFsaWdubWVudCwgZGVmYXVsdHMgdG8gJ2xlZnQnXG4gIGZpeGVkOiBib29sLCAgICAgICAgICAgICAgICAgICAgLy8gaXMgY29sdW1uIGZpeGVkXG4gIGFsbG93Q2VsbHNSZWN5Y2xpbmc6IGJvb2wsICAgICAgLy8gYWxsb3cgY2VsbHMgdG8gYmUgcmVjeWNsZWQgZm9yIGJldHRlciBob3Jpem9udGFsIHNjcm9sbGluZyBwZXJmXG4gIGRpc2FibGVSZXNpemluZzogYm9vbCwgICAgICAgICAgLy8gZGlzYWJsZSBjb2x1bW4gcmVzaXppbmdcbiAgZGlzYWJsZUVkaXRpbmc6IGJvb2wsICAgICAgICAgICAvLyBkaXNhYmxlIGlucHV0IGNvbXBvbmVudCAobWFrZSByZWFkLW9ubHkpIHdoZW4gZWRpdGluZy9jcmVhdGluZ1xuICBkaXNhYmxlU29ydGluZzogYm9vbCwgICAgICAgICAgIC8vIGRpc2FibGUgZmlsdGVyaW5nIG9uIHRoaXMgY29sdW1uXG4gIGRpc2FibGVFZGl0aW5nT25WYWx1ZU1hdGNoOiBzaGFwZSh7IC8vIGRpc2FibGUgZWRpdGluZy9jcmVhdGluZyBpbnB1dCB3aGVuIG90aGVyIGNvbHVtbnMgdmFsdWUgbWF0Y2hcbiAgICBtYXRjaFZhbHVlS2V5UGF0aDogYXJyYXksXG4gICAgbWF0Y2hWYWx1ZTogYW55LFxuICB9KSxcbiAgb25WYWx1ZU1hdGNoQ2hhbmdlVmFsdWU6IHNoYXBlKHsgLy8gQ2hhbmdlIG90aGVyIGNvbHVtbiB2YWx1ZSB3aGVuIGRhdGEgbWF0Y2hlc1xuICAgIG1hdGNoVmFsdWU6IGFueSxcbiAgICBuZXdWYWx1ZUtleVBhdGg6IGFycmF5LFxuICAgIG5ld1ZhbHVlOiBhbnksXG4gIH0pLFxuICBmbGV4R3JvdzogbnVtYmVyLFxuICB2YWx1ZUVtcHR5Q2hlY2tlcjogZnVuYywgICAgICAgIC8vIG92ZXJyaWRlIGZ1bmN0aW9uIHRoYXQgY2hlY2tzIGlmIHZhbHVlIGlzIGNvbnNpZGVyZWQgYXMgZW1wdHlcbiAgc29ydFZhbHVlR2V0dGVyOiBmdW5jLCAgICAgICAgICAvLyBvdmVycmlkZSBzb3J0IHZhbHVlIGdldHRlciwgZGVmYXVsdHMgdG8gZ2V0SW4odmFsdWVLZXlQYXRoKVxuICBzb3J0Q29tcGFyYXRvcjogZnVuYywgICAgICAgICAgIC8vIG92ZXJyaWRlIHNvcnQgY29tcGFyYXRvciBmdW5jdGlvbiwgZGVmYXVsdCBzb3J0cyBieSB2YWx1ZVR5cGVcbiAgZmlsdGVyTWF0Y2hlcjogZnVuYywgICAgICAgICAgICAvLyBvdmVycmlkZSBmaWx0ZXIgbWF0Y2hlciBmdW5jdGlvbiwgdGhhdCBkZWZpbmVkIHdoZW4gZmlsdGVyIG1hdGNoZXMgZGF0YVxuICBkZWZhdWx0VmFsdWU6IGFueSwgICAgICAgICAgICAgIC8vIGRlZmF1bHQgdmFsdWUgZm9yIHRoZSBjb2x1bW4gd2hlbiBjcmVhdGluZyBuZXcgaXRlbVxuICBpc1JlcXVpcmVkOiBib29sLCAgICAgICAgICAgICAgIC8vIGlzIGNvbHVtbiB2YWx1ZSByZXF1aXJlZFxuICBpc0hpZGRlbjogYm9vbCwgICAgICAgICAgICAgICAgIC8vIGlzIGNvbHVtbiBoaWRkZW4gYnkgZGVmYXVsdFxuICBvbkVkaXRWYWx1ZUNoYW5nZTogZnVuYywgICAgICAgIC8vIGNhbGxiYWNrIHdpdGggKHZhbHVlLCB2YWx1ZUtleVBhdGgsIHJvd0luZGV4LCBkYXRhSWQpXG4gIG9uQ3JlYXRlVmFsdWVDaGFuZ2U6IGZ1bmMsICAgICAgLy8gY2FsbGJhYyB3aXRoICh2YWx1ZSwgdmFsdWVLZXlQYXRoLCByb3dJbmRleClcbiAgb25DcmVhdGVCbHVyOiBmdW5jLCAgICAgICAgICAgICAvLyBjYWxsYmFjayB3aXRoICh2YWx1ZSwgcm93SW5kZXgpXG4gIG9uRWRpdEJsdXI6IGZ1bmMsICAgICAgICAgICAgICAgLy8gY2FsbGJhY2sgd2l0aCAodmFsdWUsIHJvd0luZGV4LCBkYXRhSWQpXG4gIHNlbGVjdENvbXBvbmVudE9wdGlvbnM6IGFycmF5T2Yoc2hhcGUoe1xuICAgIHZhbHVlOiBvbmVPZlR5cGUoW251bWJlciwgc3RyaW5nLCBib29sXSkuaXNSZXF1aXJlZCxcbiAgICBsYWJlbDogb25lT2ZUeXBlKFtudW1iZXIsIHN0cmluZ10pLmlzUmVxdWlyZWQsXG4gIH0pKSxcbiAgc2VsZWN0Q29tcG9uZW50VHJhbnNsYXRpb25zOiBzaGFwZSh7IC8vIGN1c3RvbWl6ZSBzZWxlY3QgY29tcG9uZW50cyBwbGFjZWhvbGRlciBhbmQgbm9SZXN1bHRzIHRleHRzLlxuICAgIHBsYWNlaG9sZGVyOiBzdHJpbmcsXG4gICAgbm9SZXN1bHRzVGV4dDogc3RyaW5nLFxuICB9KSxcbn0pO1xuXG5leHBvcnQgY29uc3QgcHJvcFR5cGVzID0ge1xuICBjaGlsZHJlbjogbm9kZSxcbiAgLy8gQXBwIHByb3BzXG4gIGludGw6IG9iamVjdC5pc1JlcXVpcmVkLFxuICAvLyBBY3Rpb24gcHJvcHNcbiAgYWRkTmV3SXRlbTogZnVuYy5pc1JlcXVpcmVkLFxuICByZW1vdmVOZXdJdGVtOiBmdW5jLmlzUmVxdWlyZWQsXG4gIGNyZWF0ZTogZnVuYy5pc1JlcXVpcmVkLFxuICBlZGl0OiBmdW5jLmlzUmVxdWlyZWQsXG4gIHJlbW92ZTogZnVuYy5pc1JlcXVpcmVkLFxuICBzYXZlOiBmdW5jLmlzUmVxdWlyZWQsXG4gIGNhbmNlbDogZnVuYy5pc1JlcXVpcmVkLFxuICBzb3J0Q2hhbmdlOiBmdW5jLmlzUmVxdWlyZWQsXG4gIHJlc2l6ZUNvbHVtbjogZnVuYy5pc1JlcXVpcmVkLFxuICBpbnZhbGlkYXRlOiBmdW5jLmlzUmVxdWlyZWQsXG4gIGNlbGxTZWxlY3Rpb25DaGFuZ2U6IGZ1bmMuaXNSZXF1aXJlZCxcbiAgaXRlbVNlbGVjdGlvbkNoYW5nZTogZnVuYy5pc1JlcXVpcmVkLFxuICB0b2dnbGVGaWx0ZXJpbmc6IGZ1bmMuaXNSZXF1aXJlZCxcbiAgZWRpdENlbGxWYWx1ZUNoYW5nZTogZnVuYy5pc1JlcXVpcmVkLFxuICBjcmVhdGVDZWxsVmFsdWVDaGFuZ2U6IGZ1bmMuaXNSZXF1aXJlZCxcbiAgZmlsdGVyQ2VsbFZhbHVlQ2hhbmdlOiBmdW5jLmlzUmVxdWlyZWQsXG4gIGVkaXRDZWxsVmFsdWVWYWxpZGF0ZTogZnVuYy5pc1JlcXVpcmVkLFxuICBjcmVhdGVDZWxsVmFsdWVWYWxpZGF0ZTogZnVuYy5pc1JlcXVpcmVkLFxuICB2YWxpZGF0ZUVkaXRlZFJvd3M6IGZ1bmMuaXNSZXF1aXJlZCxcbiAgdmFsaWRhdGVDcmVhdGVkUm93czogZnVuYy5pc1JlcXVpcmVkLFxuICAvLyBTdGF0ZSBwcm9wc1xuICBpc0J1c3k6IGJvb2wuaXNSZXF1aXJlZCxcbiAgaXNFZGl0aW5nOiBib29sLmlzUmVxdWlyZWQsXG4gIGlzQ3JlYXRpbmc6IGJvb2wuaXNSZXF1aXJlZCxcbiAgaXNGaWx0ZXJpbmc6IGJvb2wuaXNSZXF1aXJlZCxcbiAgc29ydENvbHVtbjogb25lT2ZUeXBlKFtcbiAgICBzdHJpbmcsXG4gICAgbnVtYmVyLFxuICBdKSxcbiAgc29ydE9yZGVyOiBzdHJpbmcsXG4gIHZpc2libGVDb2x1bW5zOiBsaXN0LmlzUmVxdWlyZWQsXG4gIGNvbHVtbldpZHRoczogbWFwLmlzUmVxdWlyZWQsXG4gIHNlbGVjdGVkQ2VsbDogbWFwLmlzUmVxdWlyZWQsXG4gIHNlbGVjdGVkSXRlbXM6IGxpc3QuaXNSZXF1aXJlZCxcbiAgZGF0YTogbGlzdC5pc1JlcXVpcmVkLFxuICBlZGl0RGF0YTogbWFwLmlzUmVxdWlyZWQsXG4gIGNyZWF0ZURhdGE6IGxpc3QuaXNSZXF1aXJlZCxcbiAgZmlsdGVyRGF0YTogbWFwLmlzUmVxdWlyZWQsXG4gIGNlbGxNZXNzYWdlczogbWFwLmlzUmVxdWlyZWQsXG4gIGNyZWF0ZUNlbGxNZXNzYWdlczogbWFwLmlzUmVxdWlyZWQsXG4gIGxhbmd1YWdlOiBzdHJpbmcuaXNSZXF1aXJlZCxcbiAgdGhvdXNhbmRTZXBhcmF0b3I6IHN0cmluZy5pc1JlcXVpcmVkLFxuICBkZWNpbWFsU2VwYXJhdG9yOiBzdHJpbmcuaXNSZXF1aXJlZCxcbiAgYWxsRGF0YVNpemU6IG51bWJlci5pc1JlcXVpcmVkLFxuICAvLyBSZXF1aXJlZCBjb21wb25lbnQgcHJvcGVydGllc1xuICBncmlkOiBncmlkU2hhcGUuaXNSZXF1aXJlZCxcbiAgY29sdW1uczogYXJyYXlPZihjb2x1bW5TaGFwZS5pc1JlcXVpcmVkKS5pc1JlcXVpcmVkLFxuICAvLyBPcHRpb25hbCBjb21wb25lbnQgcHJvcGVydGllc1xuICByb3dzQ291bnQ6IG51bWJlcixcbiAgZ3JpZEhlYWRlcjogbm9kZSxcbiAgYWN0aW9uQmFyOiBub2RlLFxuICBhY3Rpb25CYXJMZWZ0OiBub2RlLFxuICBjZWxsU2VsZWN0OiBib29sLFxuICBkaXNhYmxlRHJvcGRvd246IGJvb2wsICAgICAgICAgICAgICAvLyBEb24ndCB1c2UgZHJvcGRvd24gbWVudSBpbiB0aGUgYWN0aW9uIGJhclxuICBkaXNhYmxlRmlsdGVyaW5nQ29udHJvbHM6IGJvb2wsICAgICAvLyBEb24ndCBkaXNwbGF5IHRoZSBmaWx0ZXJpbmcgY29udHJvbHMgKG9ubHkgdmFsaWQgaWYgZGlzYWJsZURyb3Bkb3duIGlzIHRydWUpXG4gIGRyb3Bkb3duTWVudUl0ZW1zOiBhcnJheSxcbiAgaW5saW5lRWRpdDogYm9vbCxcbiAgaW5saW5lQWRkOiBib29sLFxuICBmaWx0ZXJpbmc6IGJvb2wsXG4gIHJlbW92aW5nOiBib29sLFxuICBjb2x1bW5TZXR0aW5nczogYm9vbCxcbiAgcm93U2VsZWN0OiBib29sLFxuICByb3dTZWxlY3RDaGVja2JveENvbHVtbjogYm9vbCxcbiAgbXVsdGlTZWxlY3Q6IGJvb2wsXG4gIHNlbGVjdENvbXBvbmVudE9wdGlvbnM6IG1hcE9mKGFycmF5T2Yoc2hhcGUoeyAgLy8gT3B0aW9ucyBkYXRhIGZvciB0aGUgcmVhY3Qtc2VsZWN0IGNvbXBvbmVudHNcbiAgICB2YWx1ZTogb25lT2ZUeXBlKFtudW1iZXIsIHN0cmluZywgYm9vbF0pLmlzUmVxdWlyZWQsXG4gICAgbGFiZWw6IG9uZU9mVHlwZShbbnVtYmVyLCBzdHJpbmddKS5pc1JlcXVpcmVkLFxuICB9KSkpLFxuICBzZWxlY3RDb21wb25lbnRUcmFuc2xhdGlvbnM6IHNoYXBlKHsgIC8vIE9wdGlvbnMgZm9yIHJlYWN0LXNlbGVjdCB0ZXh0IHRyYW5zbGF0aW9uc1xuICAgIHBsYWNlaG9sZGVyOiBzdHJpbmcuaXNSZXF1aXJlZCxcbiAgICBub1Jlc3VsdHNUZXh0OiBzdHJpbmcuaXNSZXF1aXJlZCxcbiAgfSksXG4gIGRpc2FibGVBY3Rpb25zOiBib29sLCAgICAgICAgICAgICAgIC8vIERpc2FibGUgYWN0aW9ucyBpbiB0aGUgYWN0aW9uIGJhclxuICBkaXNhYmxlQWN0aW9uc01lc3NhZ2U6IHNoYXBlKHtcbiAgICBtZXNzYWdlSWQ6IHN0cmluZyxcbiAgICBtZXNzYWdlVmFsdWVzOiBzaGFwZSh7fSksXG4gIH0pLFxuICBkaXNhYmxlQWN0aW9uQmFyOiBib29sLFxuICBkaXNhYmxlQWN0aW9uU2F2ZTogYm9vbCxcbiAgZW5hYmxlQXJyb3dOYXZpZ2F0aW9uOiBib29sLFxuICBvblNhdmU6IGZ1bmMsXG4gIG9uUmVtb3ZlOiBmdW5jLFxuICBvbkNhbmNlbDogZnVuYyxcbiAgb25BZGRDbGljazogZnVuYyxcbiAgb25FZGl0Q2xpY2s6IGZ1bmMsXG4gIHRhYkluZGV4OiBudW1iZXIsICAgICAgICAgICAgICAgICAgIC8vIHRhYkluZGV4IHZhbHVlIGZvciBpbnB1dHMgaW4gY2VsbHNcbiAgZXh0cmFDb2x1bW46IHNoYXBlKHsgICAgICAgICAgICAgICAgLy8gRXh0cmEgZml4ZWQgY29sdW1uIHRoYXQgY2FuJ3QgYmUgcmUtb3JkZXJlZCBvciBoaWRkZW5cbiAgICB3aWR0aDogc3RyaW5nLFxuICAgIHZhbHVlUmVuZGVyOiBmdW5jLFxuICAgIGNlbGxFZGl0OiBmdW5jLFxuICAgIGNlbGxDcmVhdGU6IGZ1bmMsXG4gICAgY2VsbEZpbHRlcjogZnVuYyxcbiAgICBpc1Jlc2l6YWJsZTogYm9vbCxcbiAgfSksXG4gIGNvbnRleHRNZW51SXRlbXM6IGFycmF5T2Yoc2hhcGUoeyAgIC8vIENvbnRleHQgbWVudSBpdGVtcyB0byBkaXNwbGF5IHdoZW4gcm93IGlzIHJpZ2h0LWNsaWNrZWRcbiAgICB2YWx1ZTogbm9kZSxcbiAgICBvbkNsaWNrOiBmdW5jLFxuICAgIHRpdGxlOiBzdHJpbmcsXG4gICAgaGVhZGVyOiBib29sLFxuICAgIGRpc2FibGVkOiBvbmVPZlR5cGUoW2Jvb2wsIGZ1bmNdKSxcbiAgICBkaXZpZGVyOiBib29sLFxuICB9KSksXG4gIC8vIEZpeGVkIGRhdGEgdGFibGUgYnVpbHQtaW4gZmVhdHVyZXNcbiAgaGVhZGVySGVpZ2h0OiBudW1iZXIsXG4gIGZpbHRlclJvd0hlaWdodDogbnVtYmVyLFxuICByb3dIZWlnaHQ6IG51bWJlcixcbiAgY29udGFpbmVyU3R5bGU6IG9iamVjdCxcbiAgc2Nyb2xsVG9Db2x1bW46IG51bWJlcixcbiAgc2Nyb2xsVG9wOiBudW1iZXIsXG4gIHNjcm9sbFRvUm93OiBudW1iZXIsXG4gIG9uUm93Q2xpY2s6IGZ1bmMsXG4gIG9uUm93RG91YmxlQ2xpY2s6IGZ1bmMsXG4gIG9uUm93TW91c2VEb3duOiBmdW5jLFxuICBvblJvd01vdXNlRW50ZXI6IGZ1bmMsXG4gIG9uUm93TW91c2VMZWF2ZTogZnVuYyxcbiAgb25TY3JvbGxTdGFydDogZnVuYyxcbiAgb25TY3JvbGxFbmQ6IGZ1bmMsXG4gIHJvd0NsYXNzTmFtZUdldHRlcjogZnVuYyxcbiAgcm93SGVpZ2h0R2V0dGVyOiBmdW5jLFxuICBvbkNvbnRlbnRIZWlnaHRDaGFuZ2U6IGZ1bmMsXG59O1xuXG4vKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4sIHByZWZlci10ZW1wbGF0ZSwgcmVhY3Qvbm8tdW51c2VkLXByb3AtdHlwZXMsIHJlYWN0L2ZvcmJpZC1wcm9wLXR5cGVzICovXG5cbmV4cG9ydCBjb25zdCBkZWZhdWx0UHJvcHMgPSB7XG4gIGNlbGxTZWxlY3Q6IGZhbHNlLFxuICBjb2x1bW5TZXR0aW5nczogZmFsc2UsXG4gIGNoaWxkcmVuOiB1bmRlZmluZWQsXG4gIGNvbnRhaW5lclN0eWxlOiB7fSxcbiAgZGlzYWJsZUFjdGlvblNhdmU6IGZhbHNlLFxuICBlbmFibGVBcnJvd05hdmlnYXRpb246IGZhbHNlLFxuICBoZWFkZXJIZWlnaHQ6IDQwLFxuICBmaWx0ZXJSb3dIZWlnaHQ6IDQwLFxuICByb3dIZWlnaHQ6IDQwLFxuICBvblNhdmU6ICgpID0+IHt9LFxuICBvblJlbW92ZTogKCkgPT4ge30sXG4gIG9uQ2FuY2VsOiAoKSA9PiB7fSxcbiAgdGFiSW5kZXg6IDEsXG4gIGRpc2FibGVGaWx0ZXJpbmdDb250cm9sczogZmFsc2UsXG59O1xuIl19